{"version":3,"file":"rapier-2686a024.js","sources":["../../node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.wasm?url","../../../../../../../__vite-plugin-wasm-helper","../../node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js","../../node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.wasm","../../node_modules/@dimforge/rapier3d/math.js","../../node_modules/@dimforge/rapier3d/dynamics/rigid_body.js","../../node_modules/@dimforge/rapier3d/coarena.js","../../node_modules/@dimforge/rapier3d/dynamics/rigid_body_set.js","../../node_modules/@dimforge/rapier3d/dynamics/integration_parameters.js","../../node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js","../../node_modules/@dimforge/rapier3d/dynamics/impulse_joint_set.js","../../node_modules/@dimforge/rapier3d/dynamics/multibody_joint.js","../../node_modules/@dimforge/rapier3d/dynamics/multibody_joint_set.js","../../node_modules/@dimforge/rapier3d/dynamics/coefficient_combine_rule.js","../../node_modules/@dimforge/rapier3d/dynamics/ccd_solver.js","../../node_modules/@dimforge/rapier3d/dynamics/island_manager.js","../../node_modules/@dimforge/rapier3d/geometry/broad_phase.js","../../node_modules/@dimforge/rapier3d/geometry/narrow_phase.js","../../node_modules/@dimforge/rapier3d/geometry/contact.js","../../node_modules/@dimforge/rapier3d/geometry/feature.js","../../node_modules/@dimforge/rapier3d/geometry/point.js","../../node_modules/@dimforge/rapier3d/geometry/ray.js","../../node_modules/@dimforge/rapier3d/geometry/toi.js","../../node_modules/@dimforge/rapier3d/geometry/shape.js","../../node_modules/@dimforge/rapier3d/geometry/collider.js","../../node_modules/@dimforge/rapier3d/geometry/collider_set.js","../../node_modules/@dimforge/rapier3d/pipeline/physics_pipeline.js","../../node_modules/@dimforge/rapier3d/pipeline/query_pipeline.js","../../node_modules/@dimforge/rapier3d/pipeline/serialization_pipeline.js","../../node_modules/@dimforge/rapier3d/pipeline/debug_render_pipeline.js","../../node_modules/@dimforge/rapier3d/control/character_controller.js","../../node_modules/@dimforge/rapier3d/pipeline/world.js","../../node_modules/@dimforge/rapier3d/pipeline/event_queue.js","../../node_modules/@dimforge/rapier3d/pipeline/physics_hooks.js","../../node_modules/@dimforge/rapier3d/exports.js"],"sourcesContent":["export default \"__VITE_ASSET__f4f67aff__\"","export default async (opts = {}, url) => {\n    let result;\n    if (url.startsWith(\"data:\")) {\n        const urlContent = url.replace(/^data:.*?base64,/, \"\");\n        let bytes;\n        if (typeof Buffer === \"function\" && typeof Buffer.from === \"function\") {\n            bytes = Buffer.from(urlContent, \"base64\");\n        }\n        else if (typeof atob === \"function\") {\n            const binaryString = atob(urlContent);\n            bytes = new Uint8Array(binaryString.length);\n            for (let i = 0; i < binaryString.length; i++) {\n                bytes[i] = binaryString.charCodeAt(i);\n            }\n        }\n        else {\n            throw new Error(\"Cannot decode base64-encoded data URL\");\n        }\n        result = await WebAssembly.instantiate(bytes, opts);\n    }\n    else {\n        // https://github.com/mdn/webassembly-examples/issues/5\n        // WebAssembly.instantiateStreaming requires the server to provide the\n        // correct MIME type for .wasm files, which unfortunately doesn't work for\n        // a lot of static file servers, so we just work around it by getting the\n        // raw buffer.\n        // @ts-ignore\n        const response = await fetch(url);\n        const contentType = response.headers.get(\"Content-Type\") || \"\";\n        if (\"instantiateStreaming\" in WebAssembly && contentType.startsWith(\"application/wasm\")) {\n            result = await WebAssembly.instantiateStreaming(response, opts);\n        }\n        else {\n            const buffer = await response.arrayBuffer();\n            result = await WebAssembly.instantiate(buffer, opts);\n        }\n    }\n    return result.instance.exports;\n}","import * as wasm from './rapier_wasm3d_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = new Float32Array();\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = new Uint32Array();\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Spherical:3,\"3\":\"Spherical\",Generic:4,\"4\":\"Generic\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ X:0,\"0\":\"X\",Y:1,\"1\":\"Y\",Z:2,\"2\":\"Z\",AngX:3,\"3\":\"AngX\",AngY:4,\"4\":\"AngY\",AngZ:5,\"5\":\"AngZ\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Edge:1,\"1\":\"Edge\",Face:2,\"2\":\"Face\",Unknown:3,\"3\":\"Unknown\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolyhedron:9,\"9\":\"ConvexPolyhedron\",Cylinder:10,\"10\":\"Cylinder\",Cone:11,\"11\":\"Cone\",RoundCuboid:12,\"12\":\"RoundCuboid\",RoundTriangle:13,\"13\":\"RoundTriangle\",RoundCylinder:14,\"14\":\"RoundCylinder\",RoundCone:15,\"15\":\"RoundCone\",RoundConvexPolyhedron:16,\"16\":\"RoundConvexPolyhedron\",HalfSpace:17,\"17\":\"HalfSpace\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        return RawBroadPhase.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawCCDSolver.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        return RawCCDSolver.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCharacterCollision {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawCharacterCollision.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        return RawCharacterCollision.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationApplied() {\n        const ret = wasm.rawcharactercollision_translationApplied(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationRemaining() {\n        const ret = wasm.rawcharactercollision_translationRemaining(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `z`: the world-space position of the collider along the `z` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.ptr, handle, x, y, z);\n    }\n    /**\n    * Sets the rotation quaternion of this collider.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.ptr, handle, newHalfExtents.ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The number of rows on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNRows(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNRows(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The number of columns on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNCols(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNCols(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.ptr, handle, point.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.ptr, handle, colliderVel.ptr, shape2.ptr, shape2Pos.ptr, shape2Rot.ptr, shape2Vel.ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.ptr, handle, collider1Vel.ptr, collider2handle, collider2Vel.ptr, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.ptr, handle, shape2.ptr, shapePos2.ptr, shapeRot2.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.ptr, handle, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.ptr, handle, point.ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.ptr, handle, shape.ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawcolliderset_coSetMassProperties(this.ptr, handle, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        return RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.ptr, enabled, shape.ptr, translation.ptr, rotation.ptr, massPropsMode, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.ptr, handle, islands.ptr, bodies.ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcontactforceevent_max_force_direction(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_x(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_y(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactPair.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDebugRenderPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        return RawDebugRenderPipeline.__wrap(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.ptr, bodies.ptr, colliders.ptr, impulse_joints.ptr, multibody_joints.ptr, narrow_phase.ptr);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawEventQueue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        return RawEventQueue.__wrap(ret);\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.ptr);\n    }\n}\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * Create a new joint descriptor that builds spehrical joints.\n    *\n    * A spherical joints allows three relative rotational degrees of freedom\n    * by preventing any relative translation between the anchors of the\n    * two attached rigid-bodies.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spherical(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spherical(anchor1.ptr, anchor2.ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.ptr, anchor2.ptr, axis.ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.ptr, axes1.ptr, anchor2.ptr, axes2.ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation along one axis.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2, axis) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.ptr, anchor2.ptr, axis.ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.ptr, handle, newPos.ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.ptr, handle, newPos.ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        return RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.ptr, params.ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        return RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedLinearError() {\n        const ret = wasm.rawintegrationparameters_allowedLinearError(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get predictionDistance() {\n        const ret = wasm.rawintegrationparameters_predictionDistance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityFrictionIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxStabilizationIterations() {\n        const ret = wasm.rawintegrationparameters_maxStabilizationIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawintegrationparameters_minIslandSize(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedLinearError(value) {\n        wasm.rawintegrationparameters_set_allowedLinearError(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set predictionDistance(value) {\n        wasm.rawintegrationparameters_set_predictionDistance(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityFrictionIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxStabilizationIterations(value) {\n        wasm.rawintegrationparameters_set_maxStabilizationIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, value);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        return RawIslandManager.__wrap(ret);\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawKinematicCharacterController {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawKinematicCharacterController.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        return RawKinematicCharacterController.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawkinematiccharactercontroller_up(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.ptr, vector.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawkinematiccharactercontroller_offset(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.ptr, dt, bodies.ptr, colliders.ptr, queries.ptr, collider_handle, desired_translation.ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.ptr, i, collision.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        return RawMultibodyJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.ptr, params.ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        return RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contacts_with(handle1, f) {\n        wasm.rawnarrowphase_contacts_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersections_with(handle1, f) {\n        wasm.rawnarrowphase_intersections_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPhysicsPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        return RawPhysicsPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, articulations.ptr, ccd_solver.ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, articulations.ptr, ccd_solver.ptr, eventQueue.ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawQueryPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        return RawQueryPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(bodies, colliders) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.ptr, bodies.ptr, colliders.ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderToi | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.ptr, bodies.ptr, colliders.ptr, point.ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.ptr, bodies.ptr, colliders.ptr, point.ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.ptr, bodies.ptr, colliders.ptr, point.ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shapeVel.ptr, shape.ptr, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.ptr, aabbCenter.ptr, aabbHalfExtents.ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawraycolliderintersection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawraycolliderintersection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderToi {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderToi.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawrayintersection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawrayintersection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n    * Sets the rotation quaternion of this rigid-body.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.ptr, handle, linvel.ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.ptr, handle, angvel.ptr, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.ptr, handle, colliders.ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.ptr, handle, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledRotations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The principal vectors of the local angular inertia tensor of the rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbPrincipalInertiaLocalFrame(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {number} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.ptr, handle, force.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.ptr, handle, impulse.ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the world-space torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbAddTorque(this.ptr, handle, torque.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, handle, torque_impulse.ptr, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.ptr, handle, force.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, handle, impulse.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.ptr, handle, data);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        return RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {RawVector} angvel\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} translationEnabledZ\n    * @param {boolean} rotationEnabledX\n    * @param {boolean} rotationEnabledY\n    * @param {boolean} rotationEnabledZ\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {number} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.ptr, enabled, translation.ptr, rotation.ptr, gravityScale, mass, massOnly, centerOfMass.ptr, linvel.ptr, angvel.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.ptr, handle, islands.ptr, colliders.ptr, joints.ptr, articulations.ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawrigidbodyset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.ptr, colliders.ptr);\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRotation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    constructor(x, y, z, w) {\n        const ret = wasm.rawrotation_new(x, y, z, w);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The identity quaternion.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The `x` component of this quaternion.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * The `y` component of this quaternion.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * The `z` component of this quaternion.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * The `w` component of this quaternion.\n    * @returns {number}\n    */\n    get w() {\n        const ret = wasm.rawrotation_w(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSdpMatrix3 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawSdpMatrix3.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawsdpmatrix3_free(ptr);\n    }\n    /**\n    * Row major list of the upper-triangular part of the symmetric matrix.\n    * @returns {Float32Array}\n    */\n    elements() {\n        const ret = wasm.rawsdpmatrix3_elements(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawSerializationPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        return RawSerializationPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, impulse_joints.ptr, multibody_joints.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShape.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy, hz) {\n        const ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cylinder(halfHeight, radius) {\n        const ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cone(halfHeight, radius) {\n        const ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} nrows\n    * @param {number} ncols\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(nrows, ncols, heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.ptr, p2.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.ptr, p2.ptr, p3.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.ptr, p2.ptr, p3.ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape | undefined}\n    */\n    static convexMesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shapeVel1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, shapeVel2.ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.ptr, shapePos.ptr, shapeRot.ptr, point.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.ptr, shapePos.ptr, shapeRot.ptr, point.ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeColliderTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeColliderTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapecollidertoi_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawshapecontact_distance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapetoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapetoi_witness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcontactforceevent_total_force(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapetoi_normal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapetoi_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawVector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 3D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 3D vector.\n    * - `y`: the `y` component of this 3D vector.\n    * - `z`: the `z` component of this 3D vector.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    constructor(x, y, z) {\n        const ret = wasm.rawvector_new(x, y, z);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawvector_set_y(this.ptr, y);\n    }\n    /**\n    * The `z` component of this vector.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `z` component of this vector.\n    * @param {number} z\n    */\n    set z(z) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, z);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n    *\n    * This will effectively return a copy of `this`. This method exist for completeness with the\n    * other swizzling functions.\n    * @returns {RawVector}\n    */\n    xyz() {\n        const ret = wasm.rawvector_xyz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n    * @returns {RawVector}\n    */\n    yxz() {\n        const ret = wasm.rawvector_yxz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n    * @returns {RawVector}\n    */\n    zxy() {\n        const ret = wasm.rawvector_zxy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n    * @returns {RawVector}\n    */\n    xzy() {\n        const ret = wasm.rawvector_xzy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n    * @returns {RawVector}\n    */\n    yzx() {\n        const ret = wasm.rawvector_yzx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n    * @returns {RawVector}\n    */\n    zyx() {\n        const ret = wasm.rawvector_zyx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_168da88779e35f61() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_3999bee59e9f7719() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_e1f72c051cdab859() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_bind_10dfe70e95d2a480(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_3f3d764d4747d564(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_d9aa266703cb98be(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_8c3f0052272a457a(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_83db9690f9353e79(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_9e1ae1900cb0fbd5(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_0e0314cf6675c1b9(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_9a2deed95d22668d(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_a7168e4a1e8f5e12(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","\nURL = globalThis.URL\nimport __vite__wasmUrl from \"/home/runner/work/folio_3js/folio_3js/node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.wasm?url\"\nimport __vite__initWasm from \"/__vite-plugin-wasm-helper\"\n\nimport { __wbindgen_object_drop_ref as __vite__wasmImport_0_0, __wbindgen_number_new as __vite__wasmImport_0_1, __wbindgen_number_get as __vite__wasmImport_0_2, __wbindgen_boolean_get as __vite__wasmImport_0_3, __wbindgen_is_function as __vite__wasmImport_0_4, __wbg_rawraycolliderintersection_new as __vite__wasmImport_0_5, __wbg_rawcontactforceevent_new as __vite__wasmImport_0_6, __wbg_call_168da88779e35f61 as __vite__wasmImport_0_7, __wbg_call_3999bee59e9f7719 as __vite__wasmImport_0_8, __wbg_call_e1f72c051cdab859 as __vite__wasmImport_0_9, __wbg_bind_10dfe70e95d2a480 as __vite__wasmImport_0_10, __wbg_buffer_3f3d764d4747d564 as __vite__wasmImport_0_11, __wbg_newwithbyteoffsetandlength_d9aa266703cb98be as __vite__wasmImport_0_12, __wbg_new_8c3f0052272a457a as __vite__wasmImport_0_13, __wbg_set_83db9690f9353e79 as __vite__wasmImport_0_14, __wbg_length_9e1ae1900cb0fbd5 as __vite__wasmImport_0_15, __wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4 as __vite__wasmImport_0_16, __wbg_set_0e0314cf6675c1b9 as __vite__wasmImport_0_17, __wbg_length_9a2deed95d22668d as __vite__wasmImport_0_18, __wbg_newwithlength_a7168e4a1e8f5e12 as __vite__wasmImport_0_19, __wbindgen_throw as __vite__wasmImport_0_20, __wbindgen_memory as __vite__wasmImport_0_21 } from \"./rapier_wasm3d_bg.js\";\nconst __vite__wasmModule = await __vite__initWasm({ \"./rapier_wasm3d_bg.js\": { __wbindgen_object_drop_ref: __vite__wasmImport_0_0, __wbindgen_number_new: __vite__wasmImport_0_1, __wbindgen_number_get: __vite__wasmImport_0_2, __wbindgen_boolean_get: __vite__wasmImport_0_3, __wbindgen_is_function: __vite__wasmImport_0_4, __wbg_rawraycolliderintersection_new: __vite__wasmImport_0_5, __wbg_rawcontactforceevent_new: __vite__wasmImport_0_6, __wbg_call_168da88779e35f61: __vite__wasmImport_0_7, __wbg_call_3999bee59e9f7719: __vite__wasmImport_0_8, __wbg_call_e1f72c051cdab859: __vite__wasmImport_0_9, __wbg_bind_10dfe70e95d2a480: __vite__wasmImport_0_10, __wbg_buffer_3f3d764d4747d564: __vite__wasmImport_0_11, __wbg_newwithbyteoffsetandlength_d9aa266703cb98be: __vite__wasmImport_0_12, __wbg_new_8c3f0052272a457a: __vite__wasmImport_0_13, __wbg_set_83db9690f9353e79: __vite__wasmImport_0_14, __wbg_length_9e1ae1900cb0fbd5: __vite__wasmImport_0_15, __wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4: __vite__wasmImport_0_16, __wbg_set_0e0314cf6675c1b9: __vite__wasmImport_0_17, __wbg_length_9a2deed95d22668d: __vite__wasmImport_0_18, __wbg_newwithlength_a7168e4a1e8f5e12: __vite__wasmImport_0_19, __wbindgen_throw: __vite__wasmImport_0_20, __wbindgen_memory: __vite__wasmImport_0_21 } }, __vite__wasmUrl);\nexport const memory = __vite__wasmModule.memory;\nexport const version = __vite__wasmModule.version;\nexport const __wbg_rawkinematiccharactercontroller_free = __vite__wasmModule.__wbg_rawkinematiccharactercontroller_free;\nexport const rawkinematiccharactercontroller_new = __vite__wasmModule.rawkinematiccharactercontroller_new;\nexport const rawkinematiccharactercontroller_up = __vite__wasmModule.rawkinematiccharactercontroller_up;\nexport const rawkinematiccharactercontroller_setUp = __vite__wasmModule.rawkinematiccharactercontroller_setUp;\nexport const rawkinematiccharactercontroller_offset = __vite__wasmModule.rawkinematiccharactercontroller_offset;\nexport const rawkinematiccharactercontroller_setOffset = __vite__wasmModule.rawkinematiccharactercontroller_setOffset;\nexport const rawkinematiccharactercontroller_slideEnabled = __vite__wasmModule.rawkinematiccharactercontroller_slideEnabled;\nexport const rawkinematiccharactercontroller_setSlideEnabled = __vite__wasmModule.rawkinematiccharactercontroller_setSlideEnabled;\nexport const rawkinematiccharactercontroller_autostepMaxHeight = __vite__wasmModule.rawkinematiccharactercontroller_autostepMaxHeight;\nexport const rawkinematiccharactercontroller_autostepMinWidth = __vite__wasmModule.rawkinematiccharactercontroller_autostepMinWidth;\nexport const rawkinematiccharactercontroller_autostepIncludesDynamicBodies = __vite__wasmModule.rawkinematiccharactercontroller_autostepIncludesDynamicBodies;\nexport const rawkinematiccharactercontroller_autostepEnabled = __vite__wasmModule.rawkinematiccharactercontroller_autostepEnabled;\nexport const rawkinematiccharactercontroller_enableAutostep = __vite__wasmModule.rawkinematiccharactercontroller_enableAutostep;\nexport const rawkinematiccharactercontroller_disableAutostep = __vite__wasmModule.rawkinematiccharactercontroller_disableAutostep;\nexport const rawkinematiccharactercontroller_maxSlopeClimbAngle = __vite__wasmModule.rawkinematiccharactercontroller_maxSlopeClimbAngle;\nexport const rawkinematiccharactercontroller_setMaxSlopeClimbAngle = __vite__wasmModule.rawkinematiccharactercontroller_setMaxSlopeClimbAngle;\nexport const rawkinematiccharactercontroller_minSlopeSlideAngle = __vite__wasmModule.rawkinematiccharactercontroller_minSlopeSlideAngle;\nexport const rawkinematiccharactercontroller_setMinSlopeSlideAngle = __vite__wasmModule.rawkinematiccharactercontroller_setMinSlopeSlideAngle;\nexport const rawkinematiccharactercontroller_snapToGroundDistance = __vite__wasmModule.rawkinematiccharactercontroller_snapToGroundDistance;\nexport const rawkinematiccharactercontroller_enableSnapToGround = __vite__wasmModule.rawkinematiccharactercontroller_enableSnapToGround;\nexport const rawkinematiccharactercontroller_disableSnapToGround = __vite__wasmModule.rawkinematiccharactercontroller_disableSnapToGround;\nexport const rawkinematiccharactercontroller_snapToGroundEnabled = __vite__wasmModule.rawkinematiccharactercontroller_snapToGroundEnabled;\nexport const rawkinematiccharactercontroller_computeColliderMovement = __vite__wasmModule.rawkinematiccharactercontroller_computeColliderMovement;\nexport const rawkinematiccharactercontroller_computedMovement = __vite__wasmModule.rawkinematiccharactercontroller_computedMovement;\nexport const rawkinematiccharactercontroller_computedGrounded = __vite__wasmModule.rawkinematiccharactercontroller_computedGrounded;\nexport const rawkinematiccharactercontroller_numComputedCollisions = __vite__wasmModule.rawkinematiccharactercontroller_numComputedCollisions;\nexport const rawkinematiccharactercontroller_computedCollision = __vite__wasmModule.rawkinematiccharactercontroller_computedCollision;\nexport const __wbg_rawcharactercollision_free = __vite__wasmModule.__wbg_rawcharactercollision_free;\nexport const rawcharactercollision_new = __vite__wasmModule.rawcharactercollision_new;\nexport const rawcharactercollision_handle = __vite__wasmModule.rawcharactercollision_handle;\nexport const rawcharactercollision_translationApplied = __vite__wasmModule.rawcharactercollision_translationApplied;\nexport const rawcharactercollision_translationRemaining = __vite__wasmModule.rawcharactercollision_translationRemaining;\nexport const rawcharactercollision_toi = __vite__wasmModule.rawcharactercollision_toi;\nexport const rawcharactercollision_worldWitness1 = __vite__wasmModule.rawcharactercollision_worldWitness1;\nexport const rawcharactercollision_worldWitness2 = __vite__wasmModule.rawcharactercollision_worldWitness2;\nexport const rawcharactercollision_worldNormal1 = __vite__wasmModule.rawcharactercollision_worldNormal1;\nexport const rawcharactercollision_worldNormal2 = __vite__wasmModule.rawcharactercollision_worldNormal2;\nexport const __wbg_rawccdsolver_free = __vite__wasmModule.__wbg_rawccdsolver_free;\nexport const rawccdsolver_new = __vite__wasmModule.rawccdsolver_new;\nexport const rawimpulsejointset_jointType = __vite__wasmModule.rawimpulsejointset_jointType;\nexport const rawimpulsejointset_jointBodyHandle1 = __vite__wasmModule.rawimpulsejointset_jointBodyHandle1;\nexport const rawimpulsejointset_jointBodyHandle2 = __vite__wasmModule.rawimpulsejointset_jointBodyHandle2;\nexport const rawimpulsejointset_jointFrameX1 = __vite__wasmModule.rawimpulsejointset_jointFrameX1;\nexport const rawimpulsejointset_jointFrameX2 = __vite__wasmModule.rawimpulsejointset_jointFrameX2;\nexport const rawimpulsejointset_jointAnchor1 = __vite__wasmModule.rawimpulsejointset_jointAnchor1;\nexport const rawimpulsejointset_jointAnchor2 = __vite__wasmModule.rawimpulsejointset_jointAnchor2;\nexport const rawimpulsejointset_jointSetAnchor1 = __vite__wasmModule.rawimpulsejointset_jointSetAnchor1;\nexport const rawimpulsejointset_jointSetAnchor2 = __vite__wasmModule.rawimpulsejointset_jointSetAnchor2;\nexport const rawimpulsejointset_jointContactsEnabled = __vite__wasmModule.rawimpulsejointset_jointContactsEnabled;\nexport const rawimpulsejointset_jointSetContactsEnabled = __vite__wasmModule.rawimpulsejointset_jointSetContactsEnabled;\nexport const rawimpulsejointset_jointLimitsEnabled = __vite__wasmModule.rawimpulsejointset_jointLimitsEnabled;\nexport const rawimpulsejointset_jointLimitsMin = __vite__wasmModule.rawimpulsejointset_jointLimitsMin;\nexport const rawimpulsejointset_jointLimitsMax = __vite__wasmModule.rawimpulsejointset_jointLimitsMax;\nexport const rawimpulsejointset_jointSetLimits = __vite__wasmModule.rawimpulsejointset_jointSetLimits;\nexport const rawimpulsejointset_jointConfigureMotorModel = __vite__wasmModule.rawimpulsejointset_jointConfigureMotorModel;\nexport const rawimpulsejointset_jointConfigureMotorVelocity = __vite__wasmModule.rawimpulsejointset_jointConfigureMotorVelocity;\nexport const rawimpulsejointset_jointConfigureMotorPosition = __vite__wasmModule.rawimpulsejointset_jointConfigureMotorPosition;\nexport const rawimpulsejointset_jointConfigureMotor = __vite__wasmModule.rawimpulsejointset_jointConfigureMotor;\nexport const __wbg_rawimpulsejointset_free = __vite__wasmModule.__wbg_rawimpulsejointset_free;\nexport const rawimpulsejointset_new = __vite__wasmModule.rawimpulsejointset_new;\nexport const rawimpulsejointset_createJoint = __vite__wasmModule.rawimpulsejointset_createJoint;\nexport const rawimpulsejointset_remove = __vite__wasmModule.rawimpulsejointset_remove;\nexport const rawimpulsejointset_len = __vite__wasmModule.rawimpulsejointset_len;\nexport const rawimpulsejointset_contains = __vite__wasmModule.rawimpulsejointset_contains;\nexport const rawimpulsejointset_forEachJointHandle = __vite__wasmModule.rawimpulsejointset_forEachJointHandle;\nexport const rawimpulsejointset_forEachJointAttachedToRigidBody = __vite__wasmModule.rawimpulsejointset_forEachJointAttachedToRigidBody;\nexport const __wbg_rawintegrationparameters_free = __vite__wasmModule.__wbg_rawintegrationparameters_free;\nexport const rawintegrationparameters_new = __vite__wasmModule.rawintegrationparameters_new;\nexport const rawintegrationparameters_dt = __vite__wasmModule.rawintegrationparameters_dt;\nexport const rawintegrationparameters_allowedLinearError = __vite__wasmModule.rawintegrationparameters_allowedLinearError;\nexport const rawintegrationparameters_predictionDistance = __vite__wasmModule.rawintegrationparameters_predictionDistance;\nexport const rawintegrationparameters_maxVelocityIterations = __vite__wasmModule.rawintegrationparameters_maxVelocityIterations;\nexport const rawintegrationparameters_maxVelocityFrictionIterations = __vite__wasmModule.rawintegrationparameters_maxVelocityFrictionIterations;\nexport const rawintegrationparameters_maxStabilizationIterations = __vite__wasmModule.rawintegrationparameters_maxStabilizationIterations;\nexport const rawintegrationparameters_minIslandSize = __vite__wasmModule.rawintegrationparameters_minIslandSize;\nexport const rawintegrationparameters_maxCcdSubsteps = __vite__wasmModule.rawintegrationparameters_maxCcdSubsteps;\nexport const rawintegrationparameters_set_dt = __vite__wasmModule.rawintegrationparameters_set_dt;\nexport const rawintegrationparameters_set_erp = __vite__wasmModule.rawintegrationparameters_set_erp;\nexport const rawintegrationparameters_set_allowedLinearError = __vite__wasmModule.rawintegrationparameters_set_allowedLinearError;\nexport const rawintegrationparameters_set_predictionDistance = __vite__wasmModule.rawintegrationparameters_set_predictionDistance;\nexport const rawintegrationparameters_set_maxVelocityIterations = __vite__wasmModule.rawintegrationparameters_set_maxVelocityIterations;\nexport const rawintegrationparameters_set_maxVelocityFrictionIterations = __vite__wasmModule.rawintegrationparameters_set_maxVelocityFrictionIterations;\nexport const rawintegrationparameters_set_maxStabilizationIterations = __vite__wasmModule.rawintegrationparameters_set_maxStabilizationIterations;\nexport const rawintegrationparameters_set_minIslandSize = __vite__wasmModule.rawintegrationparameters_set_minIslandSize;\nexport const rawintegrationparameters_set_maxCcdSubsteps = __vite__wasmModule.rawintegrationparameters_set_maxCcdSubsteps;\nexport const __wbg_rawislandmanager_free = __vite__wasmModule.__wbg_rawislandmanager_free;\nexport const rawislandmanager_new = __vite__wasmModule.rawislandmanager_new;\nexport const rawislandmanager_forEachActiveRigidBodyHandle = __vite__wasmModule.rawislandmanager_forEachActiveRigidBodyHandle;\nexport const __wbg_rawgenericjoint_free = __vite__wasmModule.__wbg_rawgenericjoint_free;\nexport const rawgenericjoint_spherical = __vite__wasmModule.rawgenericjoint_spherical;\nexport const rawgenericjoint_prismatic = __vite__wasmModule.rawgenericjoint_prismatic;\nexport const rawgenericjoint_fixed = __vite__wasmModule.rawgenericjoint_fixed;\nexport const rawgenericjoint_revolute = __vite__wasmModule.rawgenericjoint_revolute;\nexport const rawmultibodyjointset_jointType = __vite__wasmModule.rawmultibodyjointset_jointType;\nexport const rawmultibodyjointset_jointFrameX1 = __vite__wasmModule.rawmultibodyjointset_jointFrameX1;\nexport const rawmultibodyjointset_jointFrameX2 = __vite__wasmModule.rawmultibodyjointset_jointFrameX2;\nexport const rawmultibodyjointset_jointAnchor1 = __vite__wasmModule.rawmultibodyjointset_jointAnchor1;\nexport const rawmultibodyjointset_jointAnchor2 = __vite__wasmModule.rawmultibodyjointset_jointAnchor2;\nexport const rawmultibodyjointset_jointContactsEnabled = __vite__wasmModule.rawmultibodyjointset_jointContactsEnabled;\nexport const rawmultibodyjointset_jointSetContactsEnabled = __vite__wasmModule.rawmultibodyjointset_jointSetContactsEnabled;\nexport const rawmultibodyjointset_jointLimitsEnabled = __vite__wasmModule.rawmultibodyjointset_jointLimitsEnabled;\nexport const rawmultibodyjointset_jointLimitsMin = __vite__wasmModule.rawmultibodyjointset_jointLimitsMin;\nexport const rawmultibodyjointset_jointLimitsMax = __vite__wasmModule.rawmultibodyjointset_jointLimitsMax;\nexport const __wbg_rawmultibodyjointset_free = __vite__wasmModule.__wbg_rawmultibodyjointset_free;\nexport const rawmultibodyjointset_new = __vite__wasmModule.rawmultibodyjointset_new;\nexport const rawmultibodyjointset_createJoint = __vite__wasmModule.rawmultibodyjointset_createJoint;\nexport const rawmultibodyjointset_remove = __vite__wasmModule.rawmultibodyjointset_remove;\nexport const rawmultibodyjointset_contains = __vite__wasmModule.rawmultibodyjointset_contains;\nexport const rawmultibodyjointset_forEachJointHandle = __vite__wasmModule.rawmultibodyjointset_forEachJointHandle;\nexport const rawmultibodyjointset_forEachJointAttachedToRigidBody = __vite__wasmModule.rawmultibodyjointset_forEachJointAttachedToRigidBody;\nexport const rawrigidbodyset_rbTranslation = __vite__wasmModule.rawrigidbodyset_rbTranslation;\nexport const rawrigidbodyset_rbRotation = __vite__wasmModule.rawrigidbodyset_rbRotation;\nexport const rawrigidbodyset_rbSleep = __vite__wasmModule.rawrigidbodyset_rbSleep;\nexport const rawrigidbodyset_rbIsSleeping = __vite__wasmModule.rawrigidbodyset_rbIsSleeping;\nexport const rawrigidbodyset_rbIsMoving = __vite__wasmModule.rawrigidbodyset_rbIsMoving;\nexport const rawrigidbodyset_rbNextTranslation = __vite__wasmModule.rawrigidbodyset_rbNextTranslation;\nexport const rawrigidbodyset_rbNextRotation = __vite__wasmModule.rawrigidbodyset_rbNextRotation;\nexport const rawrigidbodyset_rbSetTranslation = __vite__wasmModule.rawrigidbodyset_rbSetTranslation;\nexport const rawrigidbodyset_rbSetRotation = __vite__wasmModule.rawrigidbodyset_rbSetRotation;\nexport const rawrigidbodyset_rbSetLinvel = __vite__wasmModule.rawrigidbodyset_rbSetLinvel;\nexport const rawrigidbodyset_rbSetAngvel = __vite__wasmModule.rawrigidbodyset_rbSetAngvel;\nexport const rawrigidbodyset_rbSetNextKinematicTranslation = __vite__wasmModule.rawrigidbodyset_rbSetNextKinematicTranslation;\nexport const rawrigidbodyset_rbSetNextKinematicRotation = __vite__wasmModule.rawrigidbodyset_rbSetNextKinematicRotation;\nexport const rawrigidbodyset_rbRecomputeMassPropertiesFromColliders = __vite__wasmModule.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders;\nexport const rawrigidbodyset_rbSetAdditionalMass = __vite__wasmModule.rawrigidbodyset_rbSetAdditionalMass;\nexport const rawrigidbodyset_rbSetAdditionalMassProperties = __vite__wasmModule.rawrigidbodyset_rbSetAdditionalMassProperties;\nexport const rawrigidbodyset_rbLinvel = __vite__wasmModule.rawrigidbodyset_rbLinvel;\nexport const rawrigidbodyset_rbAngvel = __vite__wasmModule.rawrigidbodyset_rbAngvel;\nexport const rawrigidbodyset_rbLockTranslations = __vite__wasmModule.rawrigidbodyset_rbLockTranslations;\nexport const rawrigidbodyset_rbSetEnabledTranslations = __vite__wasmModule.rawrigidbodyset_rbSetEnabledTranslations;\nexport const rawrigidbodyset_rbLockRotations = __vite__wasmModule.rawrigidbodyset_rbLockRotations;\nexport const rawrigidbodyset_rbSetEnabledRotations = __vite__wasmModule.rawrigidbodyset_rbSetEnabledRotations;\nexport const rawrigidbodyset_rbDominanceGroup = __vite__wasmModule.rawrigidbodyset_rbDominanceGroup;\nexport const rawrigidbodyset_rbSetDominanceGroup = __vite__wasmModule.rawrigidbodyset_rbSetDominanceGroup;\nexport const rawrigidbodyset_rbEnableCcd = __vite__wasmModule.rawrigidbodyset_rbEnableCcd;\nexport const rawrigidbodyset_rbMass = __vite__wasmModule.rawrigidbodyset_rbMass;\nexport const rawrigidbodyset_rbInvMass = __vite__wasmModule.rawrigidbodyset_rbInvMass;\nexport const rawrigidbodyset_rbEffectiveInvMass = __vite__wasmModule.rawrigidbodyset_rbEffectiveInvMass;\nexport const rawrigidbodyset_rbLocalCom = __vite__wasmModule.rawrigidbodyset_rbLocalCom;\nexport const rawrigidbodyset_rbWorldCom = __vite__wasmModule.rawrigidbodyset_rbWorldCom;\nexport const rawrigidbodyset_rbInvPrincipalInertiaSqrt = __vite__wasmModule.rawrigidbodyset_rbInvPrincipalInertiaSqrt;\nexport const rawrigidbodyset_rbPrincipalInertiaLocalFrame = __vite__wasmModule.rawrigidbodyset_rbPrincipalInertiaLocalFrame;\nexport const rawrigidbodyset_rbPrincipalInertia = __vite__wasmModule.rawrigidbodyset_rbPrincipalInertia;\nexport const rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt = __vite__wasmModule.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt;\nexport const rawrigidbodyset_rbEffectiveAngularInertia = __vite__wasmModule.rawrigidbodyset_rbEffectiveAngularInertia;\nexport const rawrigidbodyset_rbWakeUp = __vite__wasmModule.rawrigidbodyset_rbWakeUp;\nexport const rawrigidbodyset_rbIsCcdEnabled = __vite__wasmModule.rawrigidbodyset_rbIsCcdEnabled;\nexport const rawrigidbodyset_rbNumColliders = __vite__wasmModule.rawrigidbodyset_rbNumColliders;\nexport const rawrigidbodyset_rbCollider = __vite__wasmModule.rawrigidbodyset_rbCollider;\nexport const rawrigidbodyset_rbBodyType = __vite__wasmModule.rawrigidbodyset_rbBodyType;\nexport const rawrigidbodyset_rbSetBodyType = __vite__wasmModule.rawrigidbodyset_rbSetBodyType;\nexport const rawrigidbodyset_rbIsFixed = __vite__wasmModule.rawrigidbodyset_rbIsFixed;\nexport const rawrigidbodyset_rbIsKinematic = __vite__wasmModule.rawrigidbodyset_rbIsKinematic;\nexport const rawrigidbodyset_rbIsDynamic = __vite__wasmModule.rawrigidbodyset_rbIsDynamic;\nexport const rawrigidbodyset_rbLinearDamping = __vite__wasmModule.rawrigidbodyset_rbLinearDamping;\nexport const rawrigidbodyset_rbAngularDamping = __vite__wasmModule.rawrigidbodyset_rbAngularDamping;\nexport const rawrigidbodyset_rbSetLinearDamping = __vite__wasmModule.rawrigidbodyset_rbSetLinearDamping;\nexport const rawrigidbodyset_rbSetAngularDamping = __vite__wasmModule.rawrigidbodyset_rbSetAngularDamping;\nexport const rawrigidbodyset_rbSetEnabled = __vite__wasmModule.rawrigidbodyset_rbSetEnabled;\nexport const rawrigidbodyset_rbIsEnabled = __vite__wasmModule.rawrigidbodyset_rbIsEnabled;\nexport const rawrigidbodyset_rbGravityScale = __vite__wasmModule.rawrigidbodyset_rbGravityScale;\nexport const rawrigidbodyset_rbSetGravityScale = __vite__wasmModule.rawrigidbodyset_rbSetGravityScale;\nexport const rawrigidbodyset_rbResetForces = __vite__wasmModule.rawrigidbodyset_rbResetForces;\nexport const rawrigidbodyset_rbResetTorques = __vite__wasmModule.rawrigidbodyset_rbResetTorques;\nexport const rawrigidbodyset_rbAddForce = __vite__wasmModule.rawrigidbodyset_rbAddForce;\nexport const rawrigidbodyset_rbApplyImpulse = __vite__wasmModule.rawrigidbodyset_rbApplyImpulse;\nexport const rawrigidbodyset_rbAddTorque = __vite__wasmModule.rawrigidbodyset_rbAddTorque;\nexport const rawrigidbodyset_rbApplyTorqueImpulse = __vite__wasmModule.rawrigidbodyset_rbApplyTorqueImpulse;\nexport const rawrigidbodyset_rbAddForceAtPoint = __vite__wasmModule.rawrigidbodyset_rbAddForceAtPoint;\nexport const rawrigidbodyset_rbApplyImpulseAtPoint = __vite__wasmModule.rawrigidbodyset_rbApplyImpulseAtPoint;\nexport const rawrigidbodyset_rbUserData = __vite__wasmModule.rawrigidbodyset_rbUserData;\nexport const rawrigidbodyset_rbSetUserData = __vite__wasmModule.rawrigidbodyset_rbSetUserData;\nexport const __wbg_rawrigidbodyset_free = __vite__wasmModule.__wbg_rawrigidbodyset_free;\nexport const rawrigidbodyset_new = __vite__wasmModule.rawrigidbodyset_new;\nexport const rawrigidbodyset_createRigidBody = __vite__wasmModule.rawrigidbodyset_createRigidBody;\nexport const rawrigidbodyset_remove = __vite__wasmModule.rawrigidbodyset_remove;\nexport const rawrigidbodyset_len = __vite__wasmModule.rawrigidbodyset_len;\nexport const rawrigidbodyset_contains = __vite__wasmModule.rawrigidbodyset_contains;\nexport const rawrigidbodyset_forEachRigidBodyHandle = __vite__wasmModule.rawrigidbodyset_forEachRigidBodyHandle;\nexport const rawrigidbodyset_propagateModifiedBodyPositionsToColliders = __vite__wasmModule.rawrigidbodyset_propagateModifiedBodyPositionsToColliders;\nexport const __wbg_rawbroadphase_free = __vite__wasmModule.__wbg_rawbroadphase_free;\nexport const rawbroadphase_new = __vite__wasmModule.rawbroadphase_new;\nexport const rawcolliderset_coTranslation = __vite__wasmModule.rawcolliderset_coTranslation;\nexport const rawcolliderset_coRotation = __vite__wasmModule.rawcolliderset_coRotation;\nexport const rawcolliderset_coSetTranslation = __vite__wasmModule.rawcolliderset_coSetTranslation;\nexport const rawcolliderset_coSetTranslationWrtParent = __vite__wasmModule.rawcolliderset_coSetTranslationWrtParent;\nexport const rawcolliderset_coSetRotation = __vite__wasmModule.rawcolliderset_coSetRotation;\nexport const rawcolliderset_coSetRotationWrtParent = __vite__wasmModule.rawcolliderset_coSetRotationWrtParent;\nexport const rawcolliderset_coIsSensor = __vite__wasmModule.rawcolliderset_coIsSensor;\nexport const rawcolliderset_coShapeType = __vite__wasmModule.rawcolliderset_coShapeType;\nexport const rawcolliderset_coHalfspaceNormal = __vite__wasmModule.rawcolliderset_coHalfspaceNormal;\nexport const rawcolliderset_coHalfExtents = __vite__wasmModule.rawcolliderset_coHalfExtents;\nexport const rawcolliderset_coSetHalfExtents = __vite__wasmModule.rawcolliderset_coSetHalfExtents;\nexport const rawcolliderset_coRadius = __vite__wasmModule.rawcolliderset_coRadius;\nexport const rawcolliderset_coSetRadius = __vite__wasmModule.rawcolliderset_coSetRadius;\nexport const rawcolliderset_coHalfHeight = __vite__wasmModule.rawcolliderset_coHalfHeight;\nexport const rawcolliderset_coSetHalfHeight = __vite__wasmModule.rawcolliderset_coSetHalfHeight;\nexport const rawcolliderset_coRoundRadius = __vite__wasmModule.rawcolliderset_coRoundRadius;\nexport const rawcolliderset_coSetRoundRadius = __vite__wasmModule.rawcolliderset_coSetRoundRadius;\nexport const rawcolliderset_coVertices = __vite__wasmModule.rawcolliderset_coVertices;\nexport const rawcolliderset_coIndices = __vite__wasmModule.rawcolliderset_coIndices;\nexport const rawcolliderset_coHeightfieldHeights = __vite__wasmModule.rawcolliderset_coHeightfieldHeights;\nexport const rawcolliderset_coHeightfieldScale = __vite__wasmModule.rawcolliderset_coHeightfieldScale;\nexport const rawcolliderset_coHeightfieldNRows = __vite__wasmModule.rawcolliderset_coHeightfieldNRows;\nexport const rawcolliderset_coHeightfieldNCols = __vite__wasmModule.rawcolliderset_coHeightfieldNCols;\nexport const rawcolliderset_coParent = __vite__wasmModule.rawcolliderset_coParent;\nexport const rawcolliderset_coSetEnabled = __vite__wasmModule.rawcolliderset_coSetEnabled;\nexport const rawcolliderset_coIsEnabled = __vite__wasmModule.rawcolliderset_coIsEnabled;\nexport const rawcolliderset_coFriction = __vite__wasmModule.rawcolliderset_coFriction;\nexport const rawcolliderset_coRestitution = __vite__wasmModule.rawcolliderset_coRestitution;\nexport const rawcolliderset_coDensity = __vite__wasmModule.rawcolliderset_coDensity;\nexport const rawcolliderset_coMass = __vite__wasmModule.rawcolliderset_coMass;\nexport const rawcolliderset_coVolume = __vite__wasmModule.rawcolliderset_coVolume;\nexport const rawcolliderset_coCollisionGroups = __vite__wasmModule.rawcolliderset_coCollisionGroups;\nexport const rawcolliderset_coSolverGroups = __vite__wasmModule.rawcolliderset_coSolverGroups;\nexport const rawcolliderset_coActiveHooks = __vite__wasmModule.rawcolliderset_coActiveHooks;\nexport const rawcolliderset_coActiveCollisionTypes = __vite__wasmModule.rawcolliderset_coActiveCollisionTypes;\nexport const rawcolliderset_coActiveEvents = __vite__wasmModule.rawcolliderset_coActiveEvents;\nexport const rawcolliderset_coContactForceEventThreshold = __vite__wasmModule.rawcolliderset_coContactForceEventThreshold;\nexport const rawcolliderset_coContainsPoint = __vite__wasmModule.rawcolliderset_coContainsPoint;\nexport const rawcolliderset_coCastShape = __vite__wasmModule.rawcolliderset_coCastShape;\nexport const rawcolliderset_coCastCollider = __vite__wasmModule.rawcolliderset_coCastCollider;\nexport const rawcolliderset_coIntersectsShape = __vite__wasmModule.rawcolliderset_coIntersectsShape;\nexport const rawcolliderset_coContactShape = __vite__wasmModule.rawcolliderset_coContactShape;\nexport const rawcolliderset_coContactCollider = __vite__wasmModule.rawcolliderset_coContactCollider;\nexport const rawcolliderset_coProjectPoint = __vite__wasmModule.rawcolliderset_coProjectPoint;\nexport const rawcolliderset_coIntersectsRay = __vite__wasmModule.rawcolliderset_coIntersectsRay;\nexport const rawcolliderset_coCastRay = __vite__wasmModule.rawcolliderset_coCastRay;\nexport const rawcolliderset_coCastRayAndGetNormal = __vite__wasmModule.rawcolliderset_coCastRayAndGetNormal;\nexport const rawcolliderset_coSetSensor = __vite__wasmModule.rawcolliderset_coSetSensor;\nexport const rawcolliderset_coSetRestitution = __vite__wasmModule.rawcolliderset_coSetRestitution;\nexport const rawcolliderset_coSetFriction = __vite__wasmModule.rawcolliderset_coSetFriction;\nexport const rawcolliderset_coFrictionCombineRule = __vite__wasmModule.rawcolliderset_coFrictionCombineRule;\nexport const rawcolliderset_coSetFrictionCombineRule = __vite__wasmModule.rawcolliderset_coSetFrictionCombineRule;\nexport const rawcolliderset_coRestitutionCombineRule = __vite__wasmModule.rawcolliderset_coRestitutionCombineRule;\nexport const rawcolliderset_coSetRestitutionCombineRule = __vite__wasmModule.rawcolliderset_coSetRestitutionCombineRule;\nexport const rawcolliderset_coSetCollisionGroups = __vite__wasmModule.rawcolliderset_coSetCollisionGroups;\nexport const rawcolliderset_coSetSolverGroups = __vite__wasmModule.rawcolliderset_coSetSolverGroups;\nexport const rawcolliderset_coSetActiveHooks = __vite__wasmModule.rawcolliderset_coSetActiveHooks;\nexport const rawcolliderset_coSetActiveEvents = __vite__wasmModule.rawcolliderset_coSetActiveEvents;\nexport const rawcolliderset_coSetActiveCollisionTypes = __vite__wasmModule.rawcolliderset_coSetActiveCollisionTypes;\nexport const rawcolliderset_coSetShape = __vite__wasmModule.rawcolliderset_coSetShape;\nexport const rawcolliderset_coSetContactForceEventThreshold = __vite__wasmModule.rawcolliderset_coSetContactForceEventThreshold;\nexport const rawcolliderset_coSetDensity = __vite__wasmModule.rawcolliderset_coSetDensity;\nexport const rawcolliderset_coSetMass = __vite__wasmModule.rawcolliderset_coSetMass;\nexport const rawcolliderset_coSetMassProperties = __vite__wasmModule.rawcolliderset_coSetMassProperties;\nexport const __wbg_rawcolliderset_free = __vite__wasmModule.__wbg_rawcolliderset_free;\nexport const rawcolliderset_new = __vite__wasmModule.rawcolliderset_new;\nexport const rawcolliderset_len = __vite__wasmModule.rawcolliderset_len;\nexport const rawcolliderset_contains = __vite__wasmModule.rawcolliderset_contains;\nexport const rawcolliderset_createCollider = __vite__wasmModule.rawcolliderset_createCollider;\nexport const rawcolliderset_remove = __vite__wasmModule.rawcolliderset_remove;\nexport const rawcolliderset_forEachColliderHandle = __vite__wasmModule.rawcolliderset_forEachColliderHandle;\nexport const __wbg_rawshapecontact_free = __vite__wasmModule.__wbg_rawshapecontact_free;\nexport const rawshapecontact_distance = __vite__wasmModule.rawshapecontact_distance;\nexport const __wbg_rawnarrowphase_free = __vite__wasmModule.__wbg_rawnarrowphase_free;\nexport const rawnarrowphase_new = __vite__wasmModule.rawnarrowphase_new;\nexport const rawnarrowphase_contacts_with = __vite__wasmModule.rawnarrowphase_contacts_with;\nexport const rawnarrowphase_contact_pair = __vite__wasmModule.rawnarrowphase_contact_pair;\nexport const rawnarrowphase_intersections_with = __vite__wasmModule.rawnarrowphase_intersections_with;\nexport const rawnarrowphase_intersection_pair = __vite__wasmModule.rawnarrowphase_intersection_pair;\nexport const __wbg_rawcontactmanifold_free = __vite__wasmModule.__wbg_rawcontactmanifold_free;\nexport const rawcontactpair_collider1 = __vite__wasmModule.rawcontactpair_collider1;\nexport const rawcontactpair_collider2 = __vite__wasmModule.rawcontactpair_collider2;\nexport const rawcontactpair_numContactManifolds = __vite__wasmModule.rawcontactpair_numContactManifolds;\nexport const rawcontactpair_contactManifold = __vite__wasmModule.rawcontactpair_contactManifold;\nexport const rawcontactmanifold_normal = __vite__wasmModule.rawcontactmanifold_normal;\nexport const rawcontactmanifold_local_n1 = __vite__wasmModule.rawcontactmanifold_local_n1;\nexport const rawcontactmanifold_local_n2 = __vite__wasmModule.rawcontactmanifold_local_n2;\nexport const rawcontactmanifold_subshape1 = __vite__wasmModule.rawcontactmanifold_subshape1;\nexport const rawcontactmanifold_subshape2 = __vite__wasmModule.rawcontactmanifold_subshape2;\nexport const rawcontactmanifold_num_contacts = __vite__wasmModule.rawcontactmanifold_num_contacts;\nexport const rawcontactmanifold_contact_local_p1 = __vite__wasmModule.rawcontactmanifold_contact_local_p1;\nexport const rawcontactmanifold_contact_local_p2 = __vite__wasmModule.rawcontactmanifold_contact_local_p2;\nexport const rawcontactmanifold_contact_dist = __vite__wasmModule.rawcontactmanifold_contact_dist;\nexport const rawcontactmanifold_contact_fid1 = __vite__wasmModule.rawcontactmanifold_contact_fid1;\nexport const rawcontactmanifold_contact_fid2 = __vite__wasmModule.rawcontactmanifold_contact_fid2;\nexport const rawcontactmanifold_contact_impulse = __vite__wasmModule.rawcontactmanifold_contact_impulse;\nexport const rawcontactmanifold_contact_tangent_impulse_x = __vite__wasmModule.rawcontactmanifold_contact_tangent_impulse_x;\nexport const rawcontactmanifold_contact_tangent_impulse_y = __vite__wasmModule.rawcontactmanifold_contact_tangent_impulse_y;\nexport const rawcontactmanifold_num_solver_contacts = __vite__wasmModule.rawcontactmanifold_num_solver_contacts;\nexport const rawcontactmanifold_solver_contact_point = __vite__wasmModule.rawcontactmanifold_solver_contact_point;\nexport const rawcontactmanifold_solver_contact_dist = __vite__wasmModule.rawcontactmanifold_solver_contact_dist;\nexport const rawcontactmanifold_solver_contact_friction = __vite__wasmModule.rawcontactmanifold_solver_contact_friction;\nexport const rawcontactmanifold_solver_contact_restitution = __vite__wasmModule.rawcontactmanifold_solver_contact_restitution;\nexport const rawcontactmanifold_solver_contact_tangent_velocity = __vite__wasmModule.rawcontactmanifold_solver_contact_tangent_velocity;\nexport const __wbg_rawpointprojection_free = __vite__wasmModule.__wbg_rawpointprojection_free;\nexport const __wbg_rawpointcolliderprojection_free = __vite__wasmModule.__wbg_rawpointcolliderprojection_free;\nexport const rawpointcolliderprojection_colliderHandle = __vite__wasmModule.rawpointcolliderprojection_colliderHandle;\nexport const rawpointcolliderprojection_featureType = __vite__wasmModule.rawpointcolliderprojection_featureType;\nexport const rawpointcolliderprojection_featureId = __vite__wasmModule.rawpointcolliderprojection_featureId;\nexport const __wbg_rawrayintersection_free = __vite__wasmModule.__wbg_rawrayintersection_free;\nexport const rawrayintersection_featureType = __vite__wasmModule.rawrayintersection_featureType;\nexport const rawrayintersection_featureId = __vite__wasmModule.rawrayintersection_featureId;\nexport const rawraycolliderintersection_normal = __vite__wasmModule.rawraycolliderintersection_normal;\nexport const rawraycolliderintersection_toi = __vite__wasmModule.rawraycolliderintersection_toi;\nexport const rawraycolliderintersection_featureType = __vite__wasmModule.rawraycolliderintersection_featureType;\nexport const rawraycolliderintersection_featureId = __vite__wasmModule.rawraycolliderintersection_featureId;\nexport const __wbg_rawraycollidertoi_free = __vite__wasmModule.__wbg_rawraycollidertoi_free;\nexport const __wbg_rawshape_free = __vite__wasmModule.__wbg_rawshape_free;\nexport const rawshape_cuboid = __vite__wasmModule.rawshape_cuboid;\nexport const rawshape_roundCuboid = __vite__wasmModule.rawshape_roundCuboid;\nexport const rawshape_ball = __vite__wasmModule.rawshape_ball;\nexport const rawshape_halfspace = __vite__wasmModule.rawshape_halfspace;\nexport const rawshape_capsule = __vite__wasmModule.rawshape_capsule;\nexport const rawshape_cylinder = __vite__wasmModule.rawshape_cylinder;\nexport const rawshape_roundCylinder = __vite__wasmModule.rawshape_roundCylinder;\nexport const rawshape_cone = __vite__wasmModule.rawshape_cone;\nexport const rawshape_roundCone = __vite__wasmModule.rawshape_roundCone;\nexport const rawshape_polyline = __vite__wasmModule.rawshape_polyline;\nexport const rawshape_trimesh = __vite__wasmModule.rawshape_trimesh;\nexport const rawshape_heightfield = __vite__wasmModule.rawshape_heightfield;\nexport const rawshape_segment = __vite__wasmModule.rawshape_segment;\nexport const rawshape_triangle = __vite__wasmModule.rawshape_triangle;\nexport const rawshape_roundTriangle = __vite__wasmModule.rawshape_roundTriangle;\nexport const rawshape_convexHull = __vite__wasmModule.rawshape_convexHull;\nexport const rawshape_roundConvexHull = __vite__wasmModule.rawshape_roundConvexHull;\nexport const rawshape_convexMesh = __vite__wasmModule.rawshape_convexMesh;\nexport const rawshape_roundConvexMesh = __vite__wasmModule.rawshape_roundConvexMesh;\nexport const rawshape_castShape = __vite__wasmModule.rawshape_castShape;\nexport const rawshape_intersectsShape = __vite__wasmModule.rawshape_intersectsShape;\nexport const rawshape_contactShape = __vite__wasmModule.rawshape_contactShape;\nexport const rawshape_containsPoint = __vite__wasmModule.rawshape_containsPoint;\nexport const rawshape_projectPoint = __vite__wasmModule.rawshape_projectPoint;\nexport const rawshape_intersectsRay = __vite__wasmModule.rawshape_intersectsRay;\nexport const rawshape_castRay = __vite__wasmModule.rawshape_castRay;\nexport const rawshape_castRayAndGetNormal = __vite__wasmModule.rawshape_castRayAndGetNormal;\nexport const __wbg_rawshapetoi_free = __vite__wasmModule.__wbg_rawshapetoi_free;\nexport const rawshapetoi_witness1 = __vite__wasmModule.rawshapetoi_witness1;\nexport const rawshapetoi_normal1 = __vite__wasmModule.rawshapetoi_normal1;\nexport const rawshapetoi_normal2 = __vite__wasmModule.rawshapetoi_normal2;\nexport const __wbg_rawshapecollidertoi_free = __vite__wasmModule.__wbg_rawshapecollidertoi_free;\nexport const rawshapecollidertoi_witness2 = __vite__wasmModule.rawshapecollidertoi_witness2;\nexport const rawshapecollidertoi_normal2 = __vite__wasmModule.rawshapecollidertoi_normal2;\nexport const rawrotation_new = __vite__wasmModule.rawrotation_new;\nexport const rawrotation_identity = __vite__wasmModule.rawrotation_identity;\nexport const rawrotation_y = __vite__wasmModule.rawrotation_y;\nexport const rawrotation_w = __vite__wasmModule.rawrotation_w;\nexport const rawvector_zero = __vite__wasmModule.rawvector_zero;\nexport const rawvector_new = __vite__wasmModule.rawvector_new;\nexport const rawvector_set_y = __vite__wasmModule.rawvector_set_y;\nexport const rawvector_xyz = __vite__wasmModule.rawvector_xyz;\nexport const rawvector_yxz = __vite__wasmModule.rawvector_yxz;\nexport const rawvector_zxy = __vite__wasmModule.rawvector_zxy;\nexport const rawvector_xzy = __vite__wasmModule.rawvector_xzy;\nexport const rawvector_yzx = __vite__wasmModule.rawvector_yzx;\nexport const rawvector_zyx = __vite__wasmModule.rawvector_zyx;\nexport const rawsdpmatrix3_elements = __vite__wasmModule.rawsdpmatrix3_elements;\nexport const __wbg_rawdebugrenderpipeline_free = __vite__wasmModule.__wbg_rawdebugrenderpipeline_free;\nexport const rawdebugrenderpipeline_new = __vite__wasmModule.rawdebugrenderpipeline_new;\nexport const rawdebugrenderpipeline_vertices = __vite__wasmModule.rawdebugrenderpipeline_vertices;\nexport const rawdebugrenderpipeline_colors = __vite__wasmModule.rawdebugrenderpipeline_colors;\nexport const rawdebugrenderpipeline_render = __vite__wasmModule.rawdebugrenderpipeline_render;\nexport const __wbg_raweventqueue_free = __vite__wasmModule.__wbg_raweventqueue_free;\nexport const __wbg_rawcontactforceevent_free = __vite__wasmModule.__wbg_rawcontactforceevent_free;\nexport const rawcontactforceevent_collider2 = __vite__wasmModule.rawcontactforceevent_collider2;\nexport const rawcontactforceevent_total_force = __vite__wasmModule.rawcontactforceevent_total_force;\nexport const rawcontactforceevent_total_force_magnitude = __vite__wasmModule.rawcontactforceevent_total_force_magnitude;\nexport const rawcontactforceevent_max_force_direction = __vite__wasmModule.rawcontactforceevent_max_force_direction;\nexport const rawcontactforceevent_max_force_magnitude = __vite__wasmModule.rawcontactforceevent_max_force_magnitude;\nexport const raweventqueue_new = __vite__wasmModule.raweventqueue_new;\nexport const raweventqueue_drainCollisionEvents = __vite__wasmModule.raweventqueue_drainCollisionEvents;\nexport const raweventqueue_drainContactForceEvents = __vite__wasmModule.raweventqueue_drainContactForceEvents;\nexport const raweventqueue_clear = __vite__wasmModule.raweventqueue_clear;\nexport const __wbg_rawphysicspipeline_free = __vite__wasmModule.__wbg_rawphysicspipeline_free;\nexport const rawphysicspipeline_new = __vite__wasmModule.rawphysicspipeline_new;\nexport const rawphysicspipeline_step = __vite__wasmModule.rawphysicspipeline_step;\nexport const rawphysicspipeline_stepWithEvents = __vite__wasmModule.rawphysicspipeline_stepWithEvents;\nexport const __wbg_rawquerypipeline_free = __vite__wasmModule.__wbg_rawquerypipeline_free;\nexport const rawquerypipeline_new = __vite__wasmModule.rawquerypipeline_new;\nexport const rawquerypipeline_update = __vite__wasmModule.rawquerypipeline_update;\nexport const rawquerypipeline_castRay = __vite__wasmModule.rawquerypipeline_castRay;\nexport const rawquerypipeline_castRayAndGetNormal = __vite__wasmModule.rawquerypipeline_castRayAndGetNormal;\nexport const rawquerypipeline_intersectionsWithRay = __vite__wasmModule.rawquerypipeline_intersectionsWithRay;\nexport const rawquerypipeline_intersectionWithShape = __vite__wasmModule.rawquerypipeline_intersectionWithShape;\nexport const rawquerypipeline_projectPoint = __vite__wasmModule.rawquerypipeline_projectPoint;\nexport const rawquerypipeline_projectPointAndGetFeature = __vite__wasmModule.rawquerypipeline_projectPointAndGetFeature;\nexport const rawquerypipeline_intersectionsWithPoint = __vite__wasmModule.rawquerypipeline_intersectionsWithPoint;\nexport const rawquerypipeline_castShape = __vite__wasmModule.rawquerypipeline_castShape;\nexport const rawquerypipeline_intersectionsWithShape = __vite__wasmModule.rawquerypipeline_intersectionsWithShape;\nexport const rawquerypipeline_collidersWithAabbIntersectingAabb = __vite__wasmModule.rawquerypipeline_collidersWithAabbIntersectingAabb;\nexport const __wbg_rawdeserializedworld_free = __vite__wasmModule.__wbg_rawdeserializedworld_free;\nexport const rawdeserializedworld_takeGravity = __vite__wasmModule.rawdeserializedworld_takeGravity;\nexport const rawdeserializedworld_takeIntegrationParameters = __vite__wasmModule.rawdeserializedworld_takeIntegrationParameters;\nexport const rawdeserializedworld_takeIslandManager = __vite__wasmModule.rawdeserializedworld_takeIslandManager;\nexport const rawdeserializedworld_takeBroadPhase = __vite__wasmModule.rawdeserializedworld_takeBroadPhase;\nexport const rawdeserializedworld_takeNarrowPhase = __vite__wasmModule.rawdeserializedworld_takeNarrowPhase;\nexport const rawdeserializedworld_takeBodies = __vite__wasmModule.rawdeserializedworld_takeBodies;\nexport const rawdeserializedworld_takeColliders = __vite__wasmModule.rawdeserializedworld_takeColliders;\nexport const rawdeserializedworld_takeImpulseJoints = __vite__wasmModule.rawdeserializedworld_takeImpulseJoints;\nexport const rawdeserializedworld_takeMultibodyJoints = __vite__wasmModule.rawdeserializedworld_takeMultibodyJoints;\nexport const rawserializationpipeline_serializeAll = __vite__wasmModule.rawserializationpipeline_serializeAll;\nexport const rawserializationpipeline_deserializeAll = __vite__wasmModule.rawserializationpipeline_deserializeAll;\nexport const __wbg_rawcontactpair_free = __vite__wasmModule.__wbg_rawcontactpair_free;\nexport const __wbg_rawraycolliderintersection_free = __vite__wasmModule.__wbg_rawraycolliderintersection_free;\nexport const __wbg_rawrotation_free = __vite__wasmModule.__wbg_rawrotation_free;\nexport const __wbg_rawvector_free = __vite__wasmModule.__wbg_rawvector_free;\nexport const __wbg_rawsdpmatrix3_free = __vite__wasmModule.__wbg_rawsdpmatrix3_free;\nexport const rawvector_set_x = __vite__wasmModule.rawvector_set_x;\nexport const rawvector_set_z = __vite__wasmModule.rawvector_set_z;\nexport const rawpointprojection_isInside = __vite__wasmModule.rawpointprojection_isInside;\nexport const rawpointcolliderprojection_isInside = __vite__wasmModule.rawpointcolliderprojection_isInside;\nexport const rawcolliderset_isHandleValid = __vite__wasmModule.rawcolliderset_isHandleValid;\nexport const rawshapecontact_point1 = __vite__wasmModule.rawshapecontact_point1;\nexport const rawshapecontact_point2 = __vite__wasmModule.rawshapecontact_point2;\nexport const rawshapecontact_normal2 = __vite__wasmModule.rawshapecontact_normal2;\nexport const rawpointprojection_point = __vite__wasmModule.rawpointprojection_point;\nexport const rawpointcolliderprojection_point = __vite__wasmModule.rawpointcolliderprojection_point;\nexport const rawrayintersection_normal = __vite__wasmModule.rawrayintersection_normal;\nexport const rawshapecollidertoi_witness1 = __vite__wasmModule.rawshapecollidertoi_witness1;\nexport const rawshapecontact_normal1 = __vite__wasmModule.rawshapecontact_normal1;\nexport const rawshapecollidertoi_normal1 = __vite__wasmModule.rawshapecollidertoi_normal1;\nexport const rawshapetoi_witness2 = __vite__wasmModule.rawshapetoi_witness2;\nexport const rawserializationpipeline_new = __vite__wasmModule.rawserializationpipeline_new;\nexport const rawintegrationparameters_erp = __vite__wasmModule.rawintegrationparameters_erp;\nexport const rawrayintersection_toi = __vite__wasmModule.rawrayintersection_toi;\nexport const rawraycollidertoi_toi = __vite__wasmModule.rawraycollidertoi_toi;\nexport const rawshapetoi_toi = __vite__wasmModule.rawshapetoi_toi;\nexport const rawshapecollidertoi_toi = __vite__wasmModule.rawshapecollidertoi_toi;\nexport const rawrotation_x = __vite__wasmModule.rawrotation_x;\nexport const rawrotation_z = __vite__wasmModule.rawrotation_z;\nexport const rawvector_x = __vite__wasmModule.rawvector_x;\nexport const rawvector_y = __vite__wasmModule.rawvector_y;\nexport const rawvector_z = __vite__wasmModule.rawvector_z;\nexport const rawraycolliderintersection_colliderHandle = __vite__wasmModule.rawraycolliderintersection_colliderHandle;\nexport const rawraycollidertoi_colliderHandle = __vite__wasmModule.rawraycollidertoi_colliderHandle;\nexport const rawshapecollidertoi_colliderHandle = __vite__wasmModule.rawshapecollidertoi_colliderHandle;\nexport const rawcontactforceevent_collider1 = __vite__wasmModule.rawcontactforceevent_collider1;\nexport const __wbg_rawserializationpipeline_free = __vite__wasmModule.__wbg_rawserializationpipeline_free;\nexport const __wbindgen_add_to_stack_pointer = __vite__wasmModule.__wbindgen_add_to_stack_pointer;\nexport const __wbindgen_free = __vite__wasmModule.__wbindgen_free;\nexport const __wbindgen_malloc = __vite__wasmModule.__wbindgen_malloc;\nexport const __wbindgen_exn_store = __vite__wasmModule.__wbindgen_exn_store;\n","import { RawVector, RawRotation } from \"./raw\";\n/**\n * A 3D vector.\n */\nexport class Vector3 {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\nexport class VectorOps {\n    static new(x, y, z) {\n        return new Vector3(x, y, z);\n    }\n    static intoRaw(v) {\n        return new RawVector(v.x, v.y, v.z);\n    }\n    static zeros() {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n    // FIXME: type ram: RawVector?\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n    }\n}\n/**\n * A quaternion.\n */\nexport class Quaternion {\n    constructor(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\nexport class RotationOps {\n    static identity() {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n    static intoRaw(rot) {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n        out.w = input.w;\n    }\n}\n/**\n * A 3D symmetric-positive-definite matrix.\n */\nexport class SdpMatrix3 {\n    constructor(elements) {\n        this.elements = elements;\n    }\n    /**\n     * Matrix element at row 1, column 1.\n     */\n    get m11() {\n        return this.elements[0];\n    }\n    /**\n     * Matrix element at row 1, column 2.\n     */\n    get m12() {\n        return this.elements[1];\n    }\n    /**\n     * Matrix element at row 2, column 1.\n     */\n    get m21() {\n        return this.m12;\n    }\n    /**\n     * Matrix element at row 1, column 3.\n     */\n    get m13() {\n        return this.elements[2];\n    }\n    /**\n     * Matrix element at row 3, column 1.\n     */\n    get m31() {\n        return this.m13;\n    }\n    /**\n     * Matrix element at row 2, column 2.\n     */\n    get m22() {\n        return this.elements[3];\n    }\n    /**\n     * Matrix element at row 2, column 3.\n     */\n    get m23() {\n        return this.elements[4];\n    }\n    /**\n     * Matrix element at row 3, column 2.\n     */\n    get m32() {\n        return this.m23;\n    }\n    /**\n     * Matrix element at row 3, column 3.\n     */\n    get m33() {\n        return this.elements[5];\n    }\n}\nexport class SdpMatrix3Ops {\n    static fromRaw(raw) {\n        const sdpMatrix3 = new SdpMatrix3(raw.elements());\n        raw.free();\n        return sdpMatrix3;\n    }\n}\n// #endif\n//# sourceMappingURL=math.js.map","import { RotationOps, VectorOps } from \"../math\";\n// #if DIM3\nimport { SdpMatrix3Ops } from \"../math\";\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport var RigidBodyType;\n(function (RigidBodyType) {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Dynamic\"] = 0] = \"Dynamic\";\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Fixed\"] = 1] = \"Fixed\";\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicPositionBased\"] = 2] = \"KinematicPositionBased\";\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicVelocityBased\"] = 3] = \"KinematicVelocityBased\";\n})(RigidBodyType || (RigidBodyType = {}));\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    constructor(rawSet, colliderSet, handle) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n    /** @internal */\n    finalizeDeserialization(colliderSet) {\n        this.colliderSet = colliderSet;\n    }\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockTranslations(locked, wakeUp) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockRotations(locked, wakeUp) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledTranslations(enableX, enableY, enableZ, wakeUp) {\n        return this.rawSet.rbSetEnabledTranslations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(enableX, enableY, enableZ, wakeUp) {\n        this.setEnabledTranslations(enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledRotations(enableX, enableY, enableZ, wakeUp) {\n        return this.rawSet.rbSetEnabledRotations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledRotations` with the same arguments instead.\n     */\n    restrictRotations(enableX, enableY, enableZ, wakeUp) {\n        this.setEnabledRotations(enableX, enableY, enableZ, wakeUp);\n    }\n    // #endif\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    dominanceGroup() {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    setDominanceGroup(group) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    enableCcd(enabled) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextTranslation() {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextRotation() {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    setTranslation(tra, wakeUp) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n    /**\n     * Sets the linear velocity fo this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setLinvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    gravityScale() {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setGravityScale(factor, wakeUp) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    setRotation(rot, wakeUp) {\n        this.rawSet.rbSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w, wakeUp);\n    }\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setAngvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    // #endif\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    setNextKinematicTranslation(t) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    setNextKinematicRotation(rot) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    linvel() {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    angvel() {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n    // #endif\n    /**\n     * The mass of this rigid-body.\n     */\n    mass() {\n        return this.rawSet.rbMass(this.handle);\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    effectiveInvMass() {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    invMass() {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    localCom() {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    worldCom() {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n    // #if DIM3\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    invPrincipalInertiaSqrt() {\n        return VectorOps.fromRaw(this.rawSet.rbInvPrincipalInertiaSqrt(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    principalInertia() {\n        return VectorOps.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The principal vectors of the local angular inertia tensor of the rigid-body.\n     */\n    principalInertiaLocalFrame() {\n        return RotationOps.fromRaw(this.rawSet.rbPrincipalInertiaLocalFrame(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    effectiveWorldInvInertiaSqrt() {\n        return SdpMatrix3Ops.fromRaw(this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    effectiveAngularInertia() {\n        return SdpMatrix3Ops.fromRaw(this.rawSet.rbEffectiveAngularInertia(this.handle));\n    }\n    // #endif\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    isCcdEnabled() {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    numColliders() {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    collider(i) {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    setEnabled(enabled) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this rigid-body enabled?\n     */\n    isEnabled() {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    bodyType() {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    setBodyType(type, wakeUp) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     */\n    isSleeping() {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    isMoving() {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n    /**\n     * Is this rigid-body static?\n     */\n    isFixed() {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n    /**\n     * Is this rigid-body kinematic?\n     */\n    isKinematic() {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n    /**\n     * Is this rigid-body dynamic?\n     */\n    isDynamic() {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    linearDamping() {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    angularDamping() {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setLinearDamping(factor) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);\n    }\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isnt desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMass(mass, wakeUp) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame, wakeUp) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n        this.rawSet.rbSetAdditionalMassProperties(this.handle, mass, rawCom, rawPrincipalInertia, rawInertiaFrame, wakeUp);\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setAngularDamping(factor) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetForces(wakeUp) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetTorques(wakeUp) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForce(force, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulse(impulse, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n    // #if DIM3\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addTorque(torque, wakeUp) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbAddTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyTorqueImpulse(torqueImpulse, wakeUp) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n    // #endif\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForceAtPoint(force, point, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulseAtPoint(impulse, point, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\nexport class RigidBodyDesc {\n    constructor(status) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.translationsEnabledZ = true;\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.dominanceGroup = 0;\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    static dynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    static kinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    static kinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    static fixed() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    static newDynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    static newKinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    static newKinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    static newStatic() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    setDominanceGroup(group) {\n        this.dominanceGroup = group;\n        return this;\n    }\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled  If set to `false` the rigid-body will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    setTranslation(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y, z: z };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    setRotation(rot) {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    setGravityScale(scale) {\n        this.gravityScale = scale;\n        return this;\n    }\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     */\n    setAdditionalMass(mass) {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    setLinvel(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n        this.linvel = { x: x, y: y, z: z };\n        return this;\n    }\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    setAngvel(vel) {\n        VectorOps.copy(this.angvel, vel);\n        return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     * @param centerOfMass  The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(this.angularInertiaLocalFrame, angularInertiaLocalFrame);\n        this.massOnly = false;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     */\n    enabledTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ) {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        this.translationsEnabledZ = translationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ) {\n        return this.enabledTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ);\n    }\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockTranslations() {\n        return this.enabledTranslations(false, false, false);\n    }\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    enabledRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ) {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     * @deprecated use `this.enabledRotations` with the same arguments instead.\n     */\n    restrictRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ) {\n        return this.enabledRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ);\n    }\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockRotations() {\n        return this.restrictRotations(false, false, false);\n    }\n    // #endif\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    setLinearDamping(damping) {\n        this.linearDamping = damping;\n        return this;\n    }\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    setAngularDamping(damping) {\n        this.angularDamping = damping;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    setCanSleep(can) {\n        this.canSleep = can;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping) {\n        this.sleeping = sleeping;\n        return this;\n    }\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    setCcdEnabled(enabled) {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    setUserData(data) {\n        this.userData = data;\n        return this;\n    }\n}\n//# sourceMappingURL=rigid_body.js.map","export class Coarena {\n    constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array();\n        this.size = 0;\n    }\n    set(handle, data) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n        if (this.data[i] == null)\n            this.size += 1;\n        this.data[i] = data;\n    }\n    len() {\n        return this.size;\n    }\n    delete(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null)\n                this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n    clear() {\n        this.data = new Array();\n    }\n    get(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        }\n        else {\n            return null;\n        }\n    }\n    forEach(f) {\n        for (const elt of this.data) {\n            if (elt != null)\n                f(elt);\n        }\n    }\n    getAll() {\n        return this.data.filter((elt) => elt != null);\n    }\n    index(handle) {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we dont really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n//# sourceMappingURL=coarena.js.map","import { RawRigidBodySet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { VectorOps, RotationOps } from \"../math\";\nimport { RigidBody } from \"./rigid_body\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    constructor(raw) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    finalizeDeserialization(colliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    createRigidBody(colliderSet, desc) {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n        let handle = this.raw.createRigidBody(desc.enabled, rawTra, rawRot, desc.gravityScale, desc.mass, desc.massOnly, rawCom, rawLv, \n        // #if DIM3\n        rawAv, rawPrincipalInertia, rawInertiaFrame, desc.translationsEnabledX, desc.translationsEnabledY, desc.translationsEnabledZ, desc.rotationsEnabledX, desc.rotationsEnabledY, desc.rotationsEnabledZ, \n        // #endif\n        desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.ccdEnabled, desc.dominanceGroup);\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n        this.map.set(handle, body);\n        return body;\n    }\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    remove(handle, islands, colliders, impulseJoints, multibodyJoints) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => impulseJoints.unmap(handle));\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => multibodyJoints.unmap(handle));\n        // Remove the rigid-body.\n        this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        this.map.delete(handle);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBody(islands, f) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=rigid_body_set.js.map","import { RawIntegrationParameters } from \"../raw\";\nexport class IntegrationParameters {\n    constructor(raw) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt() {\n        return this.raw.dt;\n    }\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp() {\n        return this.raw.erp;\n    }\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */\n    get allowedLinearError() {\n        return this.raw.allowedLinearError;\n    }\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */\n    get predictionDistance() {\n        return this.raw.predictionDistance;\n    }\n    /**\n     * Maximum number of iterations performed by the velocity constraints solver (default: `4`).\n     */\n    get maxVelocityIterations() {\n        return this.raw.maxVelocityIterations;\n    }\n    /**\n     * Maximum number of friction iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxVelocityFrictionIterations() {\n        return this.raw.maxVelocityFrictionIterations;\n    }\n    /**\n     * Maximum number of stabilization iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxStabilizationIterations() {\n        return this.raw.maxStabilizationIterations;\n    }\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize() {\n        return this.raw.minIslandSize;\n    }\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps() {\n        return this.raw.maxCcdSubsteps;\n    }\n    set dt(value) {\n        this.raw.dt = value;\n    }\n    set erp(value) {\n        this.raw.erp = value;\n    }\n    set allowedLinearError(value) {\n        this.raw.allowedLinearError = value;\n    }\n    set predictionDistance(value) {\n        this.raw.predictionDistance = value;\n    }\n    set maxVelocityIterations(value) {\n        this.raw.maxVelocityIterations = value;\n    }\n    set maxVelocityFrictionIterations(value) {\n        this.raw.maxVelocityFrictionIterations = value;\n    }\n    set maxStabilizationIterations(value) {\n        this.raw.maxStabilizationIterations = value;\n    }\n    set minIslandSize(value) {\n        this.raw.minIslandSize = value;\n    }\n    set maxCcdSubsteps(value) {\n        this.raw.maxCcdSubsteps = value;\n    }\n}\n//# sourceMappingURL=integration_parameters.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawGenericJoint, RawJointAxis, } from \"../raw\";\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n */\nexport var JointType;\n(function (JointType) {\n    JointType[JointType[\"Revolute\"] = 0] = \"Revolute\";\n    JointType[JointType[\"Fixed\"] = 1] = \"Fixed\";\n    JointType[JointType[\"Prismatic\"] = 2] = \"Prismatic\";\n    // #if DIM3\n    JointType[JointType[\"Spherical\"] = 3] = \"Spherical\";\n    // #endif\n})(JointType || (JointType = {}));\nexport var MotorModel;\n(function (MotorModel) {\n    MotorModel[MotorModel[\"AccelerationBased\"] = 0] = \"AccelerationBased\";\n    MotorModel[MotorModel[\"ForceBased\"] = 1] = \"ForceBased\";\n})(MotorModel || (MotorModel = {}));\nexport class ImpulseJoint {\n    constructor(rawSet, bodySet, handle) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, bodySet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalImpulseJoint(rawSet, bodySet, handle);\n            // #endif\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n    /** @internal */\n    finalizeDeserialization(bodySet) {\n        this.bodySet = bodySet;\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    body1() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    body2() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n    /**\n     * The type of this joint given as a string.\n     */\n    type() {\n        return this.rawSet.jointType(this.handle);\n    }\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    frameX1() {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    frameX2() {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n    // #endif\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    anchor1() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    anchor2() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    setAnchor1(newPos) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    setAnchor2(newPos) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * Are the limits enabled for this joint?\n     */\n    limitsEnabled() {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n    /**\n     * The min limit of this joint.\n     */\n    limitsMin() {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n    /**\n     * The max limit of this joint.\n     */\n    limitsMax() {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joints free coordinate.\n     * @param max - The maximum bound of this joints free coordinate.\n     */\n    setLimits(min, max) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n    configureMotorModel(model) {\n        this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    }\n    configureMotorVelocity(targetVel, factor) {\n        this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    }\n    configureMotorPosition(targetPos, stiffness, damping) {\n        this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    }\n    configureMotor(targetPos, targetVel, stiffness, damping) {\n        this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    }\n}\nexport class FixedImpulseJoint extends ImpulseJoint {\n}\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.X;\n    }\n}\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n// #if DIM3\nexport class SphericalImpulseJoint extends ImpulseJoint {\n}\n// #endif\nexport class JointData {\n    constructor() { }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    static fixed(anchor1, frame1, anchor2, frame2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n    // #if DIM3\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    static spherical(anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Spherical;\n        return res;\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static prismatic(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static revolute(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    // #endif\n    intoRaw() {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n                // #if DIM3\n                result = RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);\n                // #endif\n                rawAx.free();\n                break;\n            // #if DIM3\n            case JointType.Spherical:\n                result = RawGenericJoint.spherical(rawA1, rawA2);\n                break;\n            case JointType.Revolute:\n                rawAx = VectorOps.intoRaw(this.axis);\n                result = RawGenericJoint.revolute(rawA1, rawA2, rawAx);\n                rawAx.free();\n                break;\n            // #endif\n        }\n        rawA1.free();\n        rawA2.free();\n        return result;\n    }\n}\n//# sourceMappingURL=impulse_joint.js.map","import { RawImpulseJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { ImpulseJoint,\n// #endif\n } from \"./impulse_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(bodies, desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wakeUp) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=impulse_joint_set.js.map","import { RawJointAxis } from \"../raw\";\nimport { JointType, } from \"./impulse_joint\";\nexport class MultibodyJoint {\n    constructor(rawSet, handle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case JointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case JointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalMultibodyJoint(rawSet, handle);\n            // #endif\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n    //  */\n    // public frameX1(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n    //  */\n    // public frameX2(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nexport class UnitMultibodyJoint extends MultibodyJoint {\n}\nexport class FixedMultibodyJoint extends MultibodyJoint {\n}\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.X;\n    }\n}\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n// #if DIM3\nexport class SphericalMultibodyJoint extends MultibodyJoint {\n}\n// #endif\n//# sourceMappingURL=multibody_joint.js.map","import { RawMultibodyJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { MultibodyJoint,\n// #endif\n } from \"./multibody_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wake_up) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=multibody_joint_set.js.map","/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport var CoefficientCombineRule;\n(function (CoefficientCombineRule) {\n    CoefficientCombineRule[CoefficientCombineRule[\"Average\"] = 0] = \"Average\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Min\"] = 1] = \"Min\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Multiply\"] = 2] = \"Multiply\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Max\"] = 3] = \"Max\";\n})(CoefficientCombineRule || (CoefficientCombineRule = {}));\n//# sourceMappingURL=coefficient_combine_rule.js.map","import { RawCCDSolver } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    constructor(raw) {\n        this.raw = raw || new RawCCDSolver();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=ccd_solver.js.map","import { RawIslandManager } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    constructor(raw) {\n        this.raw = raw || new RawIslandManager();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBodyHandle(f) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n//# sourceMappingURL=island_manager.js.map","import { RawBroadPhase } from \"../raw\";\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    constructor(raw) {\n        this.raw = raw || new RawBroadPhase();\n    }\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=broad_phase.js.map","import { RawNarrowPhase } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    constructor(raw) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactsWith(collider1, f) {\n        this.raw.contacts_with(collider1, f);\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionsWith(collider1, f) {\n        this.raw.intersections_with(collider1, f);\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\nexport class TempContactManifold {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    normal() {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n    localNormal1() {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n    localNormal2() {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n    subshape1() {\n        return this.raw.subshape1();\n    }\n    subshape2() {\n        return this.raw.subshape2();\n    }\n    numContacts() {\n        return this.raw.num_contacts();\n    }\n    localContactPoint1(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n    localContactPoint2(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n    contactDist(i) {\n        return this.raw.contact_dist(i);\n    }\n    contactFid1(i) {\n        return this.raw.contact_fid1(i);\n    }\n    contactFid2(i) {\n        return this.raw.contact_fid2(i);\n    }\n    contactImpulse(i) {\n        return this.raw.contact_impulse(i);\n    }\n    // #if DIM3\n    contactTangentImpulseX(i) {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n    contactTangentImpulseY(i) {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n    numSolverContacts() {\n        return this.raw.num_solver_contacts();\n    }\n    solverContactPoint(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n    solverContactDist(i) {\n        return this.raw.solver_contact_dist(i);\n    }\n    solverContactFriction(i) {\n        return this.raw.solver_contact_friction(i);\n    }\n    solverContactRestitution(i) {\n        return this.raw.solver_contact_restitution(i);\n    }\n    solverContactTangentVelocity(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n//# sourceMappingURL=narrow_phase.js.map","import { VectorOps } from \"../math\";\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    constructor(dist, point1, point2, normal1, normal2) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeContact(raw.distance(), VectorOps.fromRaw(raw.point1()), VectorOps.fromRaw(raw.point2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=contact.js.map","// #if DIM3\nexport var FeatureType;\n(function (FeatureType) {\n    FeatureType[FeatureType[\"Vertex\"] = 0] = \"Vertex\";\n    FeatureType[FeatureType[\"Edge\"] = 1] = \"Edge\";\n    FeatureType[FeatureType[\"Face\"] = 2] = \"Face\";\n    FeatureType[FeatureType[\"Unknown\"] = 3] = \"Unknown\";\n})(FeatureType || (FeatureType = {}));\n// #endif\n//# sourceMappingURL=feature.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    constructor(point, isInside) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new PointProjection(VectorOps.fromRaw(raw.point()), raw.isInside());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    constructor(collider, point, isInside, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new PointColliderProjection(colliderSet.get(raw.colliderHandle()), VectorOps.fromRaw(raw.point()), raw.isInside(), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=point.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin, dir) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n    pointAt(t) {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        };\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    constructor(toi, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new RayIntersection(raw.toi(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    constructor(collider, toi, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderIntersection(colliderSet.get(raw.colliderHandle()), raw.toi(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderToi {\n    constructor(collider, toi) {\n        this.collider = collider;\n        this.toi = toi;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderToi(colliderSet.get(raw.colliderHandle()), raw.toi());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=ray.js.map","import { VectorOps } from \"../math\";\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeTOI {\n    constructor(toi, witness1, witness2, normal1, normal2) {\n        this.toi = toi;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeTOI(raw.toi(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeColliderTOI extends ShapeTOI {\n    constructor(collider, toi, witness1, witness2, normal1, normal2) {\n        super(toi, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeColliderTOI(colliderSet.get(raw.colliderHandle()), raw.toi(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=toi.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawShape } from \"../raw\";\nimport { ShapeContact } from \"./contact\";\nimport { PointProjection } from \"./point\";\nimport { RayIntersection } from \"./ray\";\nimport { ShapeTOI } from \"./toi\";\nexport class Shape {\n    /**\n     * instant mode without cache\n     */\n    static fromRaw(rawSet, handle) {\n        const rawType = rawSet.coShapeType(handle);\n        let extents;\n        let borderRadius;\n        let vs;\n        let indices;\n        let halfHeight;\n        let radius;\n        let normal;\n        switch (rawType) {\n            case ShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case ShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM3\n                return new Cuboid(extents.x, extents.y, extents.z);\n            // #endif\n            case ShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM3\n                return new RoundCuboid(extents.x, extents.y, extents.z, borderRadius);\n            // #endif\n            case ShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case ShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n                // #if DIM3\n                return new Segment(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]));\n            // #endif\n            case ShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case ShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n                // #if DIM3\n                return new Triangle(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]), VectorOps.new(vs[6], vs[7], vs[8]));\n            // #endif\n            case ShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM3\n                return new RoundTriangle(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]), VectorOps.new(vs[6], vs[7], vs[8]), borderRadius);\n            // #endif\n            case ShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n            case ShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new TriMesh(vs, indices);\n            case ShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n                // #if DIM3\n                const nrows = rawSet.coHeightfieldNRows(handle);\n                const ncols = rawSet.coHeightfieldNCols(handle);\n                return new Heightfield(nrows, ncols, heights, scale);\n            // #endif\n            // #if DIM3\n            case ShapeType.ConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new ConvexPolyhedron(vs, indices);\n            case ShapeType.RoundConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolyhedron(vs, indices, borderRadius);\n            case ShapeType.Cylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cylinder(halfHeight, radius);\n            case ShapeType.RoundCylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCylinder(halfHeight, radius, borderRadius);\n            case ShapeType.Cone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cone(halfHeight, radius);\n            case ShapeType.RoundCone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCone(halfHeight, radius, borderRadius);\n            // #endif\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stopAtPenetration) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeTOI.fromRaw(null, rawShape1.castShape(rawPos1, rawRot1, rawVel1, rawShape2, rawPos2, rawRot2, rawVel2, maxToi, stopAtPenetration));\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they dont.\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = rawShape1.intersectsShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2);\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(rawShape1.contactShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    containsPoint(shapePos, shapeRot, point) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    projectPoint(shapePos, shapeRot, point, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = PointProjection.fromRaw(rawShape.projectPoint(rawPos, rawRot, rawPoint, solid));\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    intersectsRay(ray, shapePos, shapeRot, maxToi) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.intersectsRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRay(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.castRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRayAndGetNormal(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = RayIntersection.fromRaw(rawShape.castRayAndGetNormal(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid));\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n}\n// #if DIM3\n/**\n * An enumeration representing the type of a shape.\n */\nexport var ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Ball\"] = 0] = \"Ball\";\n    ShapeType[ShapeType[\"Cuboid\"] = 1] = \"Cuboid\";\n    ShapeType[ShapeType[\"Capsule\"] = 2] = \"Capsule\";\n    ShapeType[ShapeType[\"Segment\"] = 3] = \"Segment\";\n    ShapeType[ShapeType[\"Polyline\"] = 4] = \"Polyline\";\n    ShapeType[ShapeType[\"Triangle\"] = 5] = \"Triangle\";\n    ShapeType[ShapeType[\"TriMesh\"] = 6] = \"TriMesh\";\n    ShapeType[ShapeType[\"HeightField\"] = 7] = \"HeightField\";\n    // Compound = 8,\n    ShapeType[ShapeType[\"ConvexPolyhedron\"] = 9] = \"ConvexPolyhedron\";\n    ShapeType[ShapeType[\"Cylinder\"] = 10] = \"Cylinder\";\n    ShapeType[ShapeType[\"Cone\"] = 11] = \"Cone\";\n    ShapeType[ShapeType[\"RoundCuboid\"] = 12] = \"RoundCuboid\";\n    ShapeType[ShapeType[\"RoundTriangle\"] = 13] = \"RoundTriangle\";\n    ShapeType[ShapeType[\"RoundCylinder\"] = 14] = \"RoundCylinder\";\n    ShapeType[ShapeType[\"RoundCone\"] = 15] = \"RoundCone\";\n    ShapeType[ShapeType[\"RoundConvexPolyhedron\"] = 16] = \"RoundConvexPolyhedron\";\n    ShapeType[ShapeType[\"HalfSpace\"] = 17] = \"HalfSpace\";\n})(ShapeType || (ShapeType = {}));\n// #endif\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius) {\n        super();\n        this.type = ShapeType.Ball;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.ball(this.radius);\n    }\n}\nexport class HalfSpace extends Shape {\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal) {\n        super();\n        this.type = ShapeType.HalfSpace;\n        this.normal = normal;\n    }\n    intoRaw() {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx, hy, hz) {\n        super();\n        this.type = ShapeType.Cuboid;\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM3\n        return RawShape.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);\n        // #endif\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx, hy, hz, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCuboid;\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM3\n        return RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);\n        // #endif\n    }\n}\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Capsule;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a, b) {\n        super();\n        this.type = ShapeType.Segment;\n        this.a = a;\n        this.b = b;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a, b, c) {\n        super();\n        this.type = ShapeType.Triangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a, b, c, borderRadius) {\n        super();\n        this.type = ShapeType.RoundTriangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.Polyline;\n        this.vertices = vertices;\n        this.indices = indices !== null && indices !== void 0 ? indices : new Uint32Array(0);\n    }\n    intoRaw() {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.TriMesh;\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n    intoRaw() {\n        return RawShape.trimesh(this.vertices, this.indices);\n    }\n}\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.ConvexPolyhedron;\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n    intoRaw() {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        }\n        else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(vertices, indices, borderRadius) {\n        super();\n        this.type = ShapeType.RoundConvexPolyhedron;\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(this.vertices, this.indices, this.borderRadius);\n        }\n        else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(nrows, ncols, heights, scale) {\n        super();\n        this.type = ShapeType.HeightField;\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n    }\n    intoRaw() {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(this.nrows, this.ncols, this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder extends Shape {\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Cylinder;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder extends Shape {\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight, radius, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCylinder;\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.roundCylinder(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone extends Shape {\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Cone;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone extends Shape {\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight, radius, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCone;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        return RawShape.roundCone(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n// #endif\n//# sourceMappingURL=shape.js.map","import { RotationOps, VectorOps } from \"../math\";\nimport { CoefficientCombineRule, } from \"../dynamics\";\nimport { Shape, Cuboid, Ball, Capsule, TriMesh, Polyline, Heightfield, Segment, Triangle, RoundTriangle, RoundCuboid, \n// #if DIM3\nCylinder, RoundCylinder, Cone, RoundCone, ConvexPolyhedron, RoundConvexPolyhedron,\n// #endif\n } from \"./shape\";\nimport { RayIntersection } from \"./ray\";\nimport { PointProjection } from \"./point\";\nimport { ShapeColliderTOI, ShapeTOI } from \"./toi\";\nimport { ShapeContact } from \"./contact\";\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport var ActiveCollisionTypes;\n(function (ActiveCollisionTypes) {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_DYNAMIC\"] = 1] = \"DYNAMIC_DYNAMIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_KINEMATIC\"] = 12] = \"DYNAMIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_FIXED\"] = 2] = \"DYNAMIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_KINEMATIC\"] = 52224] = \"KINEMATIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_FIXED\"] = 8704] = \"KINEMATIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"FIXED_FIXED\"] = 32] = \"FIXED_FIXED\";\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DEFAULT\"] = 15] = \"DEFAULT\";\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"ALL\"] = 60943] = \"ALL\";\n})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    constructor(colliderSet, handle, parent, shape) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        if (this.handle != null) {\n            this._parent = bodies.get(this.colliderSet.raw.coParent(this.handle));\n        }\n    }\n    ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n    /**\n     * The shape of this collider.\n     */\n    get shape() {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    isValid() {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coTranslation(this.handle));\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        return RotationOps.fromRaw(this.colliderSet.raw.coRotation(this.handle));\n    }\n    /**\n     * Is this collider a sensor?\n     */\n    isSensor() {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    setSensor(isSensor) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The colliders new shape.\n     */\n    setShape(shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body wont be disabled automatically by this).\n     */\n    setEnabled(enabled) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this collider enabled?\n     */\n    isEnabled() {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    frictionCombineRule() {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    restitutionCombineRule() {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n    /**\n     * The events active for this collider.\n     */\n    activeEvents() {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n    /**\n     * Gets the collision types active for this collider.\n     */\n    activeCollisionTypes() {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    setContactForceEventThreshold(threshold) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, threshold);\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    contactForceEventThreshold() {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    setDensity(density) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    setMass(mass) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n    // #if DIM3\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n        this.colliderSet.raw.coSetMassProperties(this.handle, mass, rawCom, rawPrincipalInertia, rawInertiaFrame);\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    setTranslation(tra) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    setTranslationWrtParent(tra) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslationWrtParent(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    setRotation(rot) {\n        this.colliderSet.raw.coSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    setRotationWrtParent(rot) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    shapeType() {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfExtents() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));\n    }\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    setHalfExtents(newHalfExtents) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    radius() {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    setRadius(newRadius) {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    roundRadius() {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    setRoundRadius(newBorderRadius) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfHeight() {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    setHalfHeight(newHalfheight) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    vertices() {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    indices() {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldHeights() {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldScale() {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldNRows() {\n        return this.colliderSet.raw.coHeightfieldNRows(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldNCols() {\n        return this.colliderSet.raw.coHeightfieldNCols(this.handle);\n    }\n    // #endif\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    parent() {\n        return this._parent;\n    }\n    /**\n     * The friction coefficient of this collider.\n     */\n    friction() {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n    /**\n     * The restitution coefficient of this collider.\n     */\n    restitution() {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n    /**\n     * The density of this collider.\n     */\n    density() {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n    /**\n     * The mass of this collider.\n     */\n    mass() {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n    /**\n     * The volume of this collider.\n     */\n    volume() {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n    /**\n     * The collision groups of this collider.\n     */\n    collisionGroups() {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n    /**\n     * The solver groups of this collider.\n     */\n    solverGroups() {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    containsPoint(point) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(this.handle, rawPoint);\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    projectPoint(point, solid) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    intersectsRay(ray, maxToi) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(this.handle, rawOrig, rawDir, maxToi);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    castShape(collider1Vel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, rawCollider1Vel, rawShape2, rawShape2Pos, rawShape2Rot, rawShape2Vel, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    castCollider(collider1Vel, collider2, collider2Vel, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n        let result = ShapeColliderTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, rawCollider1Vel, collider2.handle, rawCollider2Vel, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n        return result;\n    }\n    intersectsShape(shape2, shapePos2, shapeRot2) {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n        let result = this.colliderSet.raw.coIntersectsShape(this.handle, rawShape2, rawPos2, rawRot2);\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shape2, shape2Pos, shape2Rot, prediction) {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactShape(this.handle, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(collider2, prediction) {\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, collider2.handle, prediction));\n        return result;\n    }\n    /*\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    castRay(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(this.handle, rawOrig, rawDir, maxToi, solid);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    castRayAndGetNormal(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, rawOrig, rawDir, maxToi, solid));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n}\nexport var MassPropsMode;\n(function (MassPropsMode) {\n    MassPropsMode[MassPropsMode[\"Density\"] = 0] = \"Density\";\n    MassPropsMode[MassPropsMode[\"Mass\"] = 1] = \"Mass\";\n    MassPropsMode[MassPropsMode[\"MassProps\"] = 2] = \"MassProps\";\n})(MassPropsMode || (MassPropsMode = {}));\nexport class ColliderDesc {\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 4294967295;\n        this.solverGroups = 4294967295;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = 0;\n        this.activeHooks = 0;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    static ball(radius) {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    static capsule(halfHeight, radius) {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    static segment(a, b) {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    static triangle(a, b, c) {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    static roundTriangle(a, b, c, borderRadius) {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    static polyline(vertices, indices) {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    static trimesh(vertices, indices) {\n        const shape = new TriMesh(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    static cuboid(hx, hy, hz) {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    static heightfield(nrows, ncols, heights, scale) {\n        const shape = new Heightfield(nrows, ncols, heights, scale);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    static cylinder(halfHeight, radius) {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    static cone(halfHeight, radius) {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    static convexHull(points) {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    static convexMesh(vertices, indices) {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    static roundConvexHull(points, borderRadius) {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const shape = new RoundConvexPolyhedron(vertices, indices, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setTranslation(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y, z: z };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setRotation(rot) {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    setSensor(sensor) {\n        this.isSensor = sensor;\n        return this;\n    }\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled  If set to `false` the collider will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the colliders shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    setDensity(density) {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the colliders shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    setMass(mass) {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass  The mass of the collider to create.\n     * @param centerOfMass  The center-of-mass of the collider to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(this.angularInertiaLocalFrame, angularInertiaLocalFrame);\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.restitution = restitution;\n        return this;\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.friction = friction;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.collisionGroups = groups;\n        return this;\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.solverGroups = groups;\n        return this;\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    setContactForceEventThreshold(threshold) {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n//# sourceMappingURL=collider.js.map","import { RawColliderSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { RotationOps, VectorOps } from \"../math\";\nimport { Collider } from \"./collider\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    constructor(raw) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    castClosure(f) {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            }\n            else {\n                return undefined;\n            }\n        };\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((collider) => collider.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    createCollider(bodies, desc, parentHandle) {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n        let handle = this.raw.createCollider(desc.enabled, rawShape, rawTra, rawRot, desc.massPropsMode, desc.mass, rawCom, \n        // #if DIM3\n        rawPrincipalInertia, rawInertiaFrame, \n        // #endif\n        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, desc.contactForceEventThreshold, hasParent, hasParent ? parentHandle : 0, bodies.raw);\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * The number of colliders on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=collider_set.js.map","import { RawPhysicsPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nexport class PhysicsPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {\n        let rawG = VectorOps.intoRaw(gravity);\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);\n        }\n        else {\n            this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);\n        }\n        rawG.free();\n    }\n}\n//# sourceMappingURL=physics_pipeline.js.map","import { RawQueryPipeline } from \"../raw\";\nimport { PointColliderProjection, RayColliderIntersection, RayColliderToi, ShapeColliderTOI, } from \"../geometry\";\nimport { RotationOps, VectorOps } from \"../math\";\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport var QueryFilterFlags;\n(function (QueryFilterFlags) {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_FIXED\"] = 1] = \"EXCLUDE_FIXED\";\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_KINEMATIC\"] = 2] = \"EXCLUDE_KINEMATIC\";\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_DYNAMIC\"] = 4] = \"EXCLUDE_DYNAMIC\";\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SENSORS\"] = 8] = \"EXCLUDE_SENSORS\";\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SOLIDS\"] = 16] = \"EXCLUDE_SOLIDS\";\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_DYNAMIC\"] = 3] = \"ONLY_DYNAMIC\";\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_KINEMATIC\"] = 5] = \"ONLY_KINEMATIC\";\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_FIXED\"] = 6] = \"ONLY_FIXED\";\n})(QueryFilterFlags || (QueryFilterFlags = {}));\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    update(bodies, colliders) {\n        this.raw.update(bodies.raw, colliders.raw);\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderToi.fromRaw(colliders, this.raw.castRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(bodies, colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter) => {\n            return callback(RayColliderIntersection.fromRaw(colliders, rawInter));\n        };\n        this.raw.intersectionsWithRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, rawCallback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawOrig.free();\n        rawDir.free();\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(bodies, colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(bodies.raw, colliders.raw, rawPoint, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(bodies, colliders, point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(bodies.raw, colliders.raw, rawPoint, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(bodies, colliders, point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        this.raw.intersectionsWithPoint(bodies.raw, colliders.raw, rawPoint, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPoint.free();\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n        let result = ShapeColliderTOI.fromRaw(colliders, this.raw.castShape(bodies.raw, colliders.raw, rawPos, rawRot, rawVel, rawShape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        this.raw.intersectionsWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n//# sourceMappingURL=query_pipeline.js.map","import { RawSerializationPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nimport { World } from \"./world\";\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {\n        let rawGra = VectorOps.intoRaw(gravity);\n        const res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        rawGra.free();\n        return res;\n    }\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    deserializeAll(data) {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n//# sourceMappingURL=serialization_pipeline.js.map","import { RawDebugRenderPipeline } from \"../raw\";\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    constructor(vertices, colors) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n//# sourceMappingURL=debug_render_pipeline.js.map","import { RawKinematicCharacterController, RawCharacterCollision } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n}\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    constructor(offset, params, bodies, colliders, queries) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    up() {\n        return this.raw.up();\n    }\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    setUp(vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n    applyImpulsesToDynamicBodies() {\n        return this._applyImpulsesToDynamicBodies;\n    }\n    setApplyImpulsesToDynamicBodies(enabled) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    characterMass() {\n        return this._characterMass;\n    }\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isnt attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    setCharacterMass(mass) {\n        this._characterMass = mass;\n    }\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    offset() {\n        return this.raw.offset();\n    }\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    setOffset(value) {\n        this.raw.setOffset(value);\n    }\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    slideEnabled() {\n        return this.raw.slideEnabled();\n    }\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    setSlideEnabled(enabled) {\n        this.raw.setSlideEnabled(enabled);\n    }\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    autostepMaxHeight() {\n        return this.raw.autostepMaxHeight();\n    }\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    autostepMinWidth() {\n        return this.raw.autostepMinWidth();\n    }\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    autostepIncludesDynamicBodies() {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    autostepEnabled() {\n        return this.raw.autostepEnabled();\n    }\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n    /**\n     * The maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    maxSlopeClimbAngle() {\n        return this.raw.maxSlopeClimbAngle();\n    }\n    /**\n     * Sets the maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    setMaxSlopeClimbAngle(angle) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n    /**\n     * The minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    minSlopeSlideAngle() {\n        return this.raw.minSlopeSlideAngle();\n    }\n    /**\n     * Sets the minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    setMinSlopeSlideAngle(angle) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    snapToGroundDistance() {\n        return this.raw.snapToGroundDistance();\n    }\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    enableSnapToGround(distance) {\n        this.raw.enableSnapToGround(distance);\n    }\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    snapToGroundEnabled() {\n        return this.raw.snapToGroundEnabled();\n    }\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslation - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    computeColliderMovement(collider, desiredTranslation, filterFlags, filterGroups, filterPredicate) {\n        let rawTranslation = VectorOps.intoRaw(desiredTranslation);\n        this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, collider.handle, rawTranslation, this._applyImpulsesToDynamicBodies, this._characterMass, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n        rawTranslation.free();\n    }\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    computedMovement() {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    computedGrounded() {\n        return this.raw.computedGrounded();\n    }\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    numComputedCollisions() {\n        return this.raw.numComputedCollisions();\n    }\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    computedCollision(i, out) {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        }\n        else {\n            let c = this.rawCharacterCollision;\n            out = out !== null && out !== void 0 ? out : new CharacterCollision();\n            out.translationApplied = VectorOps.fromRaw(c.translationApplied());\n            out.translationRemaining = VectorOps.fromRaw(c.translationRemaining());\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n//# sourceMappingURL=character_controller.js.map","import { BroadPhase, ColliderSet, NarrowPhase, } from \"../geometry\";\nimport { CCDSolver, IntegrationParameters, IslandManager, ImpulseJointSet, MultibodyJointSet, RigidBodySet, } from \"../dynamics\";\nimport { VectorOps } from \"../math\";\nimport { PhysicsPipeline } from \"./physics_pipeline\";\nimport { QueryPipeline } from \"./query_pipeline\";\nimport { SerializationPipeline } from \"./serialization_pipeline\";\nimport { DebugRenderBuffers, DebugRenderPipeline } from \"./debug_render_pipeline\";\nimport { KinematicCharacterController } from \"../control\";\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    constructor(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(rawIntegrationParameters);\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(rawSerializationPipeline);\n        this.debugRenderPipeline = new DebugRenderPipeline(rawDebugRenderPipeline);\n        this.characterControllers = new Set();\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        return new World(VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());\n    }\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    takeSnapshot() {\n        return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);\n    }\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    static restoreSnapshot(data) {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    debugRender() {\n        this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);\n        return new DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);\n    }\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    step(eventQueue, hooks) {\n        this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);\n    }\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n    /**\n     * The current simulation timestep.\n     */\n    get timestep() {\n        return this.integrationParameters.dt;\n    }\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt) {\n        this.integrationParameters.dt = dt;\n    }\n    /**\n     * The maximum velocity iterations the velocity-based force constraint solver can make.\n     */\n    get maxVelocityIterations() {\n        return this.integrationParameters.maxVelocityIterations;\n    }\n    /**\n     * Sets the maximum number of velocity iterations (default: 4).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityIterations(niter) {\n        this.integrationParameters.maxVelocityIterations = niter;\n    }\n    /**\n     * The maximum velocity iterations the velocity-based friction constraint solver can make.\n     */\n    get maxVelocityFrictionIterations() {\n        return this.integrationParameters.maxVelocityFrictionIterations;\n    }\n    /**\n     * Sets the maximum number of velocity iterations for friction (default: 8).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityFrictionIterations(niter) {\n        this.integrationParameters.maxVelocityFrictionIterations = niter;\n    }\n    /**\n     * The maximum velocity iterations the velocity-based constraint solver can make to attempt to remove\n     * the energy introduced by constraint stabilization.\n     */\n    get maxStabilizationIterations() {\n        return this.integrationParameters.maxStabilizationIterations;\n    }\n    /**\n     * Sets the maximum number of velocity iterations for stabilization (default: 1).\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxStabilizationIterations(niter) {\n        this.integrationParameters.maxStabilizationIterations = niter;\n    }\n    /**\n     * Creates a new rigid-body from the given rigd-body descriptior.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    createRigidBody(body) {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the characters chape and its environment.\n     */\n    createCharacterController(offset) {\n        let controller = new KinematicCharacterController(offset, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);\n        this.characterControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    removeCharacterController(controller) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    createCollider(desc, parent) {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createImpulseJoint(params, parent1, parent2, wakeUp) {\n        return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createMultibodyJoint(params, parent1, parent2, wakeUp) {\n        return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    getRigidBody(handle) {\n        return this.bodies.get(handle);\n    }\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    getCollider(handle) {\n        return this.colliders.get(handle);\n    }\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    getImpulseJoint(handle) {\n        return this.impulseJoints.get(handle);\n    }\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    getMultibodyJoint(handle) {\n        return this.multibodyJoints.get(handle);\n    }\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    removeRigidBody(body) {\n        if (this.bodies) {\n            this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);\n        }\n    }\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    removeCollider(collider, wakeUp) {\n        if (this.colliders) {\n            this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);\n        }\n    }\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeImpulseJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeMultibodyJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    forEachCollider(f) {\n        this.colliders.forEach(f);\n    }\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachRigidBody(f) {\n        this.bodies.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachActiveRigidBody(f) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRay(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let handle = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPoint(this.bodies, this.colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, point, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, point, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castShape(this.bodies, this.colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, this.colliders.castClosure(callback));\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactsWith(collider1, f) {\n        this.narrowPhase.contactsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionsWith(collider1, f) {\n        this.narrowPhase.intersectionsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);\n    }\n}\n//# sourceMappingURL=world.js.map","import { RawEventQueue } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport var ActiveEvents;\n(function (ActiveEvents) {\n    /**\n     * Enable collision events.\n     */\n    ActiveEvents[ActiveEvents[\"COLLISION_EVENTS\"] = 1] = \"COLLISION_EVENTS\";\n    /**\n     * Enable contact force events.\n     */\n    ActiveEvents[ActiveEvents[\"CONTACT_FORCE_EVENTS\"] = 2] = \"CONTACT_FORCE_EVENTS\";\n})(ActiveEvents || (ActiveEvents = {}));\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The first collider involved in the contact.\n     */\n    collider1() {\n        return this.raw.collider1();\n    }\n    /**\n     * The second collider involved in the contact.\n     */\n    collider2() {\n        return this.raw.collider2();\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    totalForce() {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    totalForceMagnitude() {\n        return this.raw.total_force_magnitude();\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    maxForceDirection() {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    maxForceMagnitude() {\n        return this.raw.max_force_magnitude();\n    }\n}\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain, raw) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    drainCollisionEvents(f) {\n        this.raw.drainCollisionEvents(f);\n    }\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    drainContactForceEvents(f) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n    /**\n     * Removes all events contained by this collector\n     */\n    clear() {\n        this.raw.clear();\n    }\n}\n//# sourceMappingURL=event_queue.js.map","export var ActiveHooks;\n(function (ActiveHooks) {\n    ActiveHooks[ActiveHooks[\"FILTER_CONTACT_PAIRS\"] = 1] = \"FILTER_CONTACT_PAIRS\";\n    ActiveHooks[ActiveHooks[\"FILTER_INTERSECTION_PAIRS\"] = 2] = \"FILTER_INTERSECTION_PAIRS\";\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n})(ActiveHooks || (ActiveHooks = {}));\nexport var SolverFlags;\n(function (SolverFlags) {\n    SolverFlags[SolverFlags[\"EMPTY\"] = 0] = \"EMPTY\";\n    SolverFlags[SolverFlags[\"COMPUTE_IMPULSE\"] = 1] = \"COMPUTE_IMPULSE\";\n})(SolverFlags || (SolverFlags = {}));\n//# sourceMappingURL=physics_hooks.js.map","import { version as vers } from \"./raw\";\nexport function version() {\n    return vers();\n}\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n//# sourceMappingURL=exports.js.map"],"names":["__vite__wasmUrl","__vite__initWasm","opts","url","result","urlContent","bytes","binaryString","i","response","contentType","buffer","heap","getObject","idx","heap_next","dropObject","takeObject","ret","addHeapObject","obj","isLikeNone","x","cachedFloat64Memory0","getFloat64Memory0","wasm.memory","cachedInt32Memory0","getInt32Memory0","lTextDecoder","cachedTextDecoder","cachedUint8Memory0","getUint8Memory0","getStringFromWasm0","ptr","len","version","retptr","wasm.__wbindgen_add_to_stack_pointer","wasm.version","r0","r1","wasm.__wbindgen_free","_assertClass","instance","klass","cachedFloat32Memory0","getFloat32Memory0","stack_pointer","addBorrowedObject","getArrayF32FromWasm0","cachedUint32Memory0","getUint32Memory0","getArrayU32FromWasm0","WASM_VECTOR_LEN","passArrayF32ToWasm0","arg","malloc","passArray32ToWasm0","handleError","f","args","wasm.__wbindgen_exn_store","RawJointAxis","RawBroadPhase","wasm.__wbg_rawbroadphase_free","wasm.rawbroadphase_new","RawCCDSolver","wasm.__wbg_rawccdsolver_free","wasm.rawccdsolver_new","RawCharacterCollision","wasm.__wbg_rawcharactercollision_free","wasm.rawcharactercollision_new","wasm.rawcharactercollision_handle","wasm.rawcharactercollision_translationApplied","RawVector","wasm.rawcharactercollision_translationRemaining","wasm.rawcharactercollision_toi","wasm.rawcharactercollision_worldWitness1","wasm.rawcharactercollision_worldWitness2","wasm.rawcharactercollision_worldNormal1","wasm.rawcharactercollision_worldNormal2","RawColliderSet","wasm.__wbg_rawcolliderset_free","handle","wasm.rawcolliderset_coTranslation","wasm.rawcolliderset_coRotation","RawRotation","y","z","wasm.rawcolliderset_coSetTranslation","wasm.rawcolliderset_coSetTranslationWrtParent","w","wasm.rawcolliderset_coSetRotation","wasm.rawcolliderset_coSetRotationWrtParent","wasm.rawcolliderset_coIsSensor","wasm.rawcolliderset_coShapeType","wasm.rawcolliderset_coHalfspaceNormal","wasm.rawcolliderset_coHalfExtents","newHalfExtents","wasm.rawcolliderset_coSetHalfExtents","wasm.rawcolliderset_coRadius","newRadius","wasm.rawcolliderset_coSetRadius","wasm.rawcolliderset_coHalfHeight","newHalfheight","wasm.rawcolliderset_coSetHalfHeight","wasm.rawcolliderset_coRoundRadius","newBorderRadius","wasm.rawcolliderset_coSetRoundRadius","wasm.rawcolliderset_coVertices","v0","wasm.rawcolliderset_coIndices","wasm.rawcolliderset_coHeightfieldHeights","wasm.rawcolliderset_coHeightfieldScale","wasm.rawcolliderset_coHeightfieldNRows","wasm.rawcolliderset_coHeightfieldNCols","wasm.rawcolliderset_coParent","r2","enabled","wasm.rawcolliderset_coSetEnabled","wasm.rawcolliderset_coIsEnabled","wasm.rawcolliderset_coFriction","wasm.rawcolliderset_coRestitution","wasm.rawcolliderset_coDensity","wasm.rawcolliderset_coMass","wasm.rawcolliderset_coVolume","wasm.rawcolliderset_coCollisionGroups","wasm.rawcolliderset_coSolverGroups","wasm.rawcolliderset_coActiveHooks","wasm.rawcolliderset_coActiveCollisionTypes","wasm.rawcolliderset_coActiveEvents","wasm.rawcolliderset_coContactForceEventThreshold","point","wasm.rawcolliderset_coContainsPoint","colliderVel","shape2","shape2Pos","shape2Rot","shape2Vel","maxToi","stop_at_penetration","RawShape","wasm.rawcolliderset_coCastShape","RawShapeTOI","collider1Vel","collider2handle","collider2Vel","max_toi","wasm.rawcolliderset_coCastCollider","RawShapeColliderTOI","shapePos2","shapeRot2","wasm.rawcolliderset_coIntersectsShape","prediction","wasm.rawcolliderset_coContactShape","RawShapeContact","wasm.rawcolliderset_coContactCollider","solid","wasm.rawcolliderset_coProjectPoint","RawPointProjection","rayOrig","rayDir","wasm.rawcolliderset_coIntersectsRay","wasm.rawcolliderset_coCastRay","wasm.rawcolliderset_coCastRayAndGetNormal","RawRayIntersection","is_sensor","wasm.rawcolliderset_coSetSensor","restitution","wasm.rawcolliderset_coSetRestitution","friction","wasm.rawcolliderset_coSetFriction","wasm.rawcolliderset_coFrictionCombineRule","rule","wasm.rawcolliderset_coSetFrictionCombineRule","wasm.rawcolliderset_coRestitutionCombineRule","wasm.rawcolliderset_coSetRestitutionCombineRule","groups","wasm.rawcolliderset_coSetCollisionGroups","wasm.rawcolliderset_coSetSolverGroups","hooks","wasm.rawcolliderset_coSetActiveHooks","events","wasm.rawcolliderset_coSetActiveEvents","types","wasm.rawcolliderset_coSetActiveCollisionTypes","shape","wasm.rawcolliderset_coSetShape","threshold","wasm.rawcolliderset_coSetContactForceEventThreshold","density","wasm.rawcolliderset_coSetDensity","mass","wasm.rawcolliderset_coSetMass","centerOfMass","principalAngularInertia","angularInertiaFrame","wasm.rawcolliderset_coSetMassProperties","wasm.rawcolliderset_new","wasm.rawcolliderset_len","wasm.rawcolliderset_contains","translation","rotation","massPropsMode","frictionCombineRule","restitutionCombineRule","isSensor","collisionGroups","solverGroups","activeCollisionTypes","activeHooks","activeEvents","contactForceEventThreshold","hasParent","parent","bodies","RawRigidBodySet","wasm.rawcolliderset_createCollider","islands","wakeUp","RawIslandManager","wasm.rawcolliderset_remove","wasm.rawcolliderset_forEachColliderHandle","RawContactForceEvent","wasm.__wbg_rawcontactforceevent_free","wasm.rawcontactforceevent_collider2","wasm.rawcontactforceevent_total_force","wasm.rawcontactforceevent_total_force_magnitude","wasm.rawcontactforceevent_max_force_direction","wasm.rawcontactforceevent_max_force_magnitude","RawContactManifold","wasm.__wbg_rawcontactmanifold_free","wasm.rawcontactmanifold_normal","wasm.rawcontactmanifold_local_n1","wasm.rawcontactmanifold_local_n2","wasm.rawcontactmanifold_subshape1","wasm.rawcontactmanifold_subshape2","wasm.rawcontactmanifold_num_contacts","wasm.rawcontactmanifold_contact_local_p1","wasm.rawcontactmanifold_contact_local_p2","wasm.rawcontactmanifold_contact_dist","wasm.rawcontactmanifold_contact_fid1","wasm.rawcontactmanifold_contact_fid2","wasm.rawcontactmanifold_contact_impulse","wasm.rawcontactmanifold_contact_tangent_impulse_x","wasm.rawcontactmanifold_contact_tangent_impulse_y","wasm.rawcontactmanifold_num_solver_contacts","wasm.rawcontactmanifold_solver_contact_point","wasm.rawcontactmanifold_solver_contact_dist","wasm.rawcontactmanifold_solver_contact_friction","wasm.rawcontactmanifold_solver_contact_restitution","wasm.rawcontactmanifold_solver_contact_tangent_velocity","RawContactPair","wasm.__wbg_rawcontactpair_free","wasm.rawcontactpair_collider1","wasm.rawcontactpair_collider2","wasm.rawcontactpair_numContactManifolds","wasm.rawcontactpair_contactManifold","RawDebugRenderPipeline","wasm.__wbg_rawdebugrenderpipeline_free","wasm.rawdebugrenderpipeline_new","wasm.rawdebugrenderpipeline_vertices","wasm.rawdebugrenderpipeline_colors","colliders","impulse_joints","multibody_joints","narrow_phase","RawImpulseJointSet","RawMultibodyJointSet","RawNarrowPhase","wasm.rawdebugrenderpipeline_render","RawDeserializedWorld","wasm.__wbg_rawdeserializedworld_free","wasm.rawdeserializedworld_takeGravity","wasm.rawdeserializedworld_takeIntegrationParameters","RawIntegrationParameters","wasm.rawdeserializedworld_takeIslandManager","wasm.rawdeserializedworld_takeBroadPhase","wasm.rawdeserializedworld_takeNarrowPhase","wasm.rawdeserializedworld_takeBodies","wasm.rawdeserializedworld_takeColliders","wasm.rawdeserializedworld_takeImpulseJoints","wasm.rawdeserializedworld_takeMultibodyJoints","RawEventQueue","wasm.__wbg_raweventqueue_free","autoDrain","wasm.raweventqueue_new","wasm.raweventqueue_drainCollisionEvents","wasm.raweventqueue_drainContactForceEvents","wasm.raweventqueue_clear","RawGenericJoint","wasm.__wbg_rawgenericjoint_free","anchor1","anchor2","wasm.rawgenericjoint_spherical","axis","limitsEnabled","limitsMin","limitsMax","wasm.rawgenericjoint_prismatic","axes1","axes2","wasm.rawgenericjoint_fixed","wasm.rawgenericjoint_revolute","wasm.__wbg_rawimpulsejointset_free","wasm.rawimpulsejointset_jointType","wasm.rawimpulsejointset_jointBodyHandle1","wasm.rawimpulsejointset_jointBodyHandle2","wasm.rawimpulsejointset_jointFrameX1","wasm.rawimpulsejointset_jointFrameX2","wasm.rawimpulsejointset_jointAnchor1","wasm.rawimpulsejointset_jointAnchor2","newPos","wasm.rawimpulsejointset_jointSetAnchor1","wasm.rawimpulsejointset_jointSetAnchor2","wasm.rawimpulsejointset_jointContactsEnabled","wasm.rawimpulsejointset_jointSetContactsEnabled","wasm.rawimpulsejointset_jointLimitsEnabled","wasm.rawimpulsejointset_jointLimitsMin","wasm.rawimpulsejointset_jointLimitsMax","min","max","wasm.rawimpulsejointset_jointSetLimits","model","wasm.rawimpulsejointset_jointConfigureMotorModel","targetVel","factor","wasm.rawimpulsejointset_jointConfigureMotorVelocity","targetPos","stiffness","damping","wasm.rawimpulsejointset_jointConfigureMotorPosition","wasm.rawimpulsejointset_jointConfigureMotor","wasm.rawimpulsejointset_new","params","parent1","parent2","wake_up","wasm.rawimpulsejointset_createJoint","wasm.rawimpulsejointset_remove","wasm.rawimpulsejointset_len","wasm.rawimpulsejointset_contains","wasm.rawimpulsejointset_forEachJointHandle","body","wasm.rawimpulsejointset_forEachJointAttachedToRigidBody","wasm.__wbg_rawintegrationparameters_free","wasm.rawintegrationparameters_new","wasm.rawintegrationparameters_dt","wasm.rawintegrationparameters_allowedLinearError","wasm.rawintegrationparameters_predictionDistance","wasm.rawintegrationparameters_maxVelocityIterations","wasm.rawintegrationparameters_maxVelocityFrictionIterations","wasm.rawintegrationparameters_maxStabilizationIterations","wasm.rawintegrationparameters_minIslandSize","wasm.rawintegrationparameters_maxCcdSubsteps","value","wasm.rawintegrationparameters_set_dt","wasm.rawintegrationparameters_set_erp","wasm.rawintegrationparameters_set_allowedLinearError","wasm.rawintegrationparameters_set_predictionDistance","wasm.rawintegrationparameters_set_maxVelocityIterations","wasm.rawintegrationparameters_set_maxVelocityFrictionIterations","wasm.rawintegrationparameters_set_maxStabilizationIterations","wasm.rawintegrationparameters_set_minIslandSize","wasm.rawintegrationparameters_set_maxCcdSubsteps","wasm.__wbg_rawislandmanager_free","wasm.rawislandmanager_new","wasm.rawislandmanager_forEachActiveRigidBodyHandle","RawKinematicCharacterController","wasm.__wbg_rawkinematiccharactercontroller_free","offset","wasm.rawkinematiccharactercontroller_new","wasm.rawkinematiccharactercontroller_up","vector","wasm.rawkinematiccharactercontroller_setUp","wasm.rawkinematiccharactercontroller_offset","wasm.rawkinematiccharactercontroller_setOffset","wasm.rawkinematiccharactercontroller_slideEnabled","wasm.rawkinematiccharactercontroller_setSlideEnabled","wasm.rawkinematiccharactercontroller_autostepMaxHeight","wasm.rawkinematiccharactercontroller_autostepMinWidth","wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies","wasm.rawkinematiccharactercontroller_autostepEnabled","maxHeight","minWidth","includeDynamicBodies","wasm.rawkinematiccharactercontroller_enableAutostep","wasm.rawkinematiccharactercontroller_disableAutostep","wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle","angle","wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle","wasm.rawkinematiccharactercontroller_minSlopeSlideAngle","wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle","wasm.rawkinematiccharactercontroller_snapToGroundDistance","distance","wasm.rawkinematiccharactercontroller_enableSnapToGround","wasm.rawkinematiccharactercontroller_disableSnapToGround","wasm.rawkinematiccharactercontroller_snapToGroundEnabled","dt","queries","collider_handle","desired_translation","apply_impulses_to_dynamic_bodies","character_mass","filter_flags","filter_groups","filter_predicate","RawQueryPipeline","wasm.rawkinematiccharactercontroller_computeColliderMovement","wasm.rawkinematiccharactercontroller_computedMovement","wasm.rawkinematiccharactercontroller_computedGrounded","wasm.rawkinematiccharactercontroller_numComputedCollisions","collision","wasm.rawkinematiccharactercontroller_computedCollision","wasm.__wbg_rawmultibodyjointset_free","wasm.rawmultibodyjointset_jointType","wasm.rawmultibodyjointset_jointFrameX1","wasm.rawmultibodyjointset_jointFrameX2","wasm.rawmultibodyjointset_jointAnchor1","wasm.rawmultibodyjointset_jointAnchor2","wasm.rawmultibodyjointset_jointContactsEnabled","wasm.rawmultibodyjointset_jointSetContactsEnabled","wasm.rawmultibodyjointset_jointLimitsEnabled","wasm.rawmultibodyjointset_jointLimitsMin","wasm.rawmultibodyjointset_jointLimitsMax","wasm.rawmultibodyjointset_new","wasm.rawmultibodyjointset_createJoint","wasm.rawmultibodyjointset_remove","wasm.rawmultibodyjointset_contains","wasm.rawmultibodyjointset_forEachJointHandle","wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody","wasm.__wbg_rawnarrowphase_free","wasm.rawnarrowphase_new","handle1","wasm.rawnarrowphase_contacts_with","handle2","wasm.rawnarrowphase_contact_pair","wasm.rawnarrowphase_intersections_with","wasm.rawnarrowphase_intersection_pair","RawPhysicsPipeline","wasm.__wbg_rawphysicspipeline_free","wasm.rawphysicspipeline_new","gravity","integrationParameters","broadPhase","narrowPhase","joints","articulations","ccd_solver","wasm.rawphysicspipeline_step","eventQueue","hookObject","hookFilterContactPair","hookFilterIntersectionPair","wasm.rawphysicspipeline_stepWithEvents","RawPointColliderProjection","wasm.__wbg_rawpointcolliderprojection_free","wasm.rawpointcolliderprojection_colliderHandle","wasm.rawpointcolliderprojection_featureType","wasm.rawpointcolliderprojection_featureId","wasm.__wbg_rawpointprojection_free","wasm.__wbg_rawquerypipeline_free","wasm.rawquerypipeline_new","wasm.rawquerypipeline_update","filter_exclude_collider","filter_exclude_rigid_body","wasm.rawquerypipeline_castRay","RawRayColliderToi","wasm.rawquerypipeline_castRayAndGetNormal","RawRayColliderIntersection","callback","wasm.rawquerypipeline_intersectionsWithRay","shapePos","shapeRot","wasm.rawquerypipeline_intersectionWithShape","wasm.rawquerypipeline_projectPoint","wasm.rawquerypipeline_projectPointAndGetFeature","wasm.rawquerypipeline_intersectionsWithPoint","shapeVel","wasm.rawquerypipeline_castShape","wasm.rawquerypipeline_intersectionsWithShape","aabbCenter","aabbHalfExtents","wasm.rawquerypipeline_collidersWithAabbIntersectingAabb","wasm.__wbg_rawraycolliderintersection_free","wasm.rawraycolliderintersection_normal","wasm.rawraycolliderintersection_toi","wasm.rawraycolliderintersection_featureType","wasm.rawraycolliderintersection_featureId","wasm.__wbg_rawraycollidertoi_free","wasm.__wbg_rawrayintersection_free","wasm.rawrayintersection_featureType","wasm.rawrayintersection_featureId","wasm.__wbg_rawrigidbodyset_free","wasm.rawrigidbodyset_rbTranslation","wasm.rawrigidbodyset_rbRotation","wasm.rawrigidbodyset_rbSleep","wasm.rawrigidbodyset_rbIsSleeping","wasm.rawrigidbodyset_rbIsMoving","wasm.rawrigidbodyset_rbNextTranslation","wasm.rawrigidbodyset_rbNextRotation","wasm.rawrigidbodyset_rbSetTranslation","wasm.rawrigidbodyset_rbSetRotation","linvel","wasm.rawrigidbodyset_rbSetLinvel","angvel","wasm.rawrigidbodyset_rbSetAngvel","wasm.rawrigidbodyset_rbSetNextKinematicTranslation","wasm.rawrigidbodyset_rbSetNextKinematicRotation","wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders","wasm.rawrigidbodyset_rbSetAdditionalMass","wasm.rawrigidbodyset_rbSetAdditionalMassProperties","wasm.rawrigidbodyset_rbLinvel","wasm.rawrigidbodyset_rbAngvel","locked","wasm.rawrigidbodyset_rbLockTranslations","allow_x","allow_y","allow_z","wasm.rawrigidbodyset_rbSetEnabledTranslations","wasm.rawrigidbodyset_rbLockRotations","wasm.rawrigidbodyset_rbSetEnabledRotations","wasm.rawrigidbodyset_rbDominanceGroup","group","wasm.rawrigidbodyset_rbSetDominanceGroup","wasm.rawrigidbodyset_rbEnableCcd","wasm.rawrigidbodyset_rbMass","wasm.rawrigidbodyset_rbInvMass","wasm.rawrigidbodyset_rbEffectiveInvMass","wasm.rawrigidbodyset_rbLocalCom","wasm.rawrigidbodyset_rbWorldCom","wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt","wasm.rawrigidbodyset_rbPrincipalInertiaLocalFrame","wasm.rawrigidbodyset_rbPrincipalInertia","wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt","RawSdpMatrix3","wasm.rawrigidbodyset_rbEffectiveAngularInertia","wasm.rawrigidbodyset_rbWakeUp","wasm.rawrigidbodyset_rbIsCcdEnabled","wasm.rawrigidbodyset_rbNumColliders","at","wasm.rawrigidbodyset_rbCollider","wasm.rawrigidbodyset_rbBodyType","status","wasm.rawrigidbodyset_rbSetBodyType","wasm.rawrigidbodyset_rbIsFixed","wasm.rawrigidbodyset_rbIsKinematic","wasm.rawrigidbodyset_rbIsDynamic","wasm.rawrigidbodyset_rbLinearDamping","wasm.rawrigidbodyset_rbAngularDamping","wasm.rawrigidbodyset_rbSetLinearDamping","wasm.rawrigidbodyset_rbSetAngularDamping","wasm.rawrigidbodyset_rbSetEnabled","wasm.rawrigidbodyset_rbIsEnabled","wasm.rawrigidbodyset_rbGravityScale","wasm.rawrigidbodyset_rbSetGravityScale","wasm.rawrigidbodyset_rbResetForces","wasm.rawrigidbodyset_rbResetTorques","force","wasm.rawrigidbodyset_rbAddForce","impulse","wasm.rawrigidbodyset_rbApplyImpulse","torque","wasm.rawrigidbodyset_rbAddTorque","torque_impulse","wasm.rawrigidbodyset_rbApplyTorqueImpulse","wasm.rawrigidbodyset_rbAddForceAtPoint","wasm.rawrigidbodyset_rbApplyImpulseAtPoint","wasm.rawrigidbodyset_rbUserData","data","wasm.rawrigidbodyset_rbSetUserData","wasm.rawrigidbodyset_new","gravityScale","massOnly","translationEnabledX","translationEnabledY","translationEnabledZ","rotationEnabledX","rotationEnabledY","rotationEnabledZ","linearDamping","angularDamping","rb_type","canSleep","sleeping","ccdEnabled","dominanceGroup","wasm.rawrigidbodyset_createRigidBody","wasm.rawrigidbodyset_remove","wasm.rawrigidbodyset_len","wasm.rawrigidbodyset_contains","wasm.rawrigidbodyset_forEachRigidBodyHandle","wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders","wasm.__wbg_rawrotation_free","wasm.rawrotation_new","wasm.rawrotation_identity","wasm.rawrotation_y","wasm.rawrotation_w","wasm.__wbg_rawsdpmatrix3_free","wasm.rawsdpmatrix3_elements","RawSerializationPipeline","wasm.__wbg_rawserializationpipeline_free","wasm.rawserializationpipeline_new","wasm.rawserializationpipeline_serializeAll","wasm.rawserializationpipeline_deserializeAll","wasm.__wbg_rawshape_free","hx","hy","hz","wasm.rawshape_cuboid","borderRadius","wasm.rawshape_roundCuboid","radius","wasm.rawshape_ball","normal","wasm.rawshape_halfspace","halfHeight","wasm.rawshape_capsule","wasm.rawshape_cylinder","wasm.rawshape_roundCylinder","wasm.rawshape_cone","wasm.rawshape_roundCone","vertices","indices","ptr0","wasm.__wbindgen_malloc","len0","ptr1","wasm.rawshape_polyline","wasm.rawshape_trimesh","nrows","ncols","heights","scale","wasm.rawshape_heightfield","p1","p2","wasm.rawshape_segment","p3","wasm.rawshape_triangle","wasm.rawshape_roundTriangle","points","wasm.rawshape_convexHull","wasm.rawshape_roundConvexHull","wasm.rawshape_convexMesh","wasm.rawshape_roundConvexMesh","shapePos1","shapeRot1","shapeVel1","shapeVel2","wasm.rawshape_castShape","wasm.rawshape_intersectsShape","wasm.rawshape_contactShape","wasm.rawshape_containsPoint","wasm.rawshape_projectPoint","wasm.rawshape_intersectsRay","wasm.rawshape_castRay","wasm.rawshape_castRayAndGetNormal","wasm.__wbg_rawshapecollidertoi_free","wasm.rawshapecollidertoi_witness2","wasm.rawshapecollidertoi_normal2","wasm.__wbg_rawshapecontact_free","wasm.rawshapecontact_distance","wasm.__wbg_rawshapetoi_free","wasm.rawshapetoi_witness1","wasm.rawshapetoi_normal1","wasm.rawshapetoi_normal2","wasm.__wbg_rawvector_free","wasm.rawvector_zero","wasm.rawvector_new","wasm.rawvector_set_y","wasm.rawvector_xyz","wasm.rawvector_yxz","wasm.rawvector_zxy","wasm.rawvector_xzy","wasm.rawvector_yzx","wasm.rawvector_zyx","__wbindgen_object_drop_ref","arg0","__wbindgen_number_new","__wbindgen_number_get","arg1","__wbindgen_boolean_get","v","__wbindgen_is_function","__wbg_rawraycolliderintersection_new","__wbg_rawcontactforceevent_new","__wbg_call_168da88779e35f61","arg2","__wbg_call_3999bee59e9f7719","arg3","__wbg_call_e1f72c051cdab859","arg4","__wbg_bind_10dfe70e95d2a480","__wbg_buffer_3f3d764d4747d564","__wbg_newwithbyteoffsetandlength_d9aa266703cb98be","__wbg_new_8c3f0052272a457a","__wbg_set_83db9690f9353e79","__wbg_length_9e1ae1900cb0fbd5","__wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4","__wbg_set_0e0314cf6675c1b9","__wbg_length_9a2deed95d22668d","__wbg_newwithlength_a7168e4a1e8f5e12","__wbindgen_throw","__wbindgen_memory","__vite__wasmModule","__vite__wasmImport_0_0","__vite__wasmImport_0_1","__vite__wasmImport_0_2","__vite__wasmImport_0_3","__vite__wasmImport_0_4","__vite__wasmImport_0_5","__vite__wasmImport_0_6","__vite__wasmImport_0_7","__vite__wasmImport_0_8","__vite__wasmImport_0_9","__vite__wasmImport_0_10","__vite__wasmImport_0_11","__vite__wasmImport_0_12","__vite__wasmImport_0_13","__vite__wasmImport_0_14","__vite__wasmImport_0_15","__vite__wasmImport_0_16","__vite__wasmImport_0_17","__vite__wasmImport_0_18","__vite__wasmImport_0_19","__vite__wasmImport_0_20","__vite__wasmImport_0_21","memory","__wbg_rawkinematiccharactercontroller_free","rawkinematiccharactercontroller_new","rawkinematiccharactercontroller_up","rawkinematiccharactercontroller_setUp","rawkinematiccharactercontroller_offset","rawkinematiccharactercontroller_setOffset","rawkinematiccharactercontroller_slideEnabled","rawkinematiccharactercontroller_setSlideEnabled","rawkinematiccharactercontroller_autostepMaxHeight","rawkinematiccharactercontroller_autostepMinWidth","rawkinematiccharactercontroller_autostepIncludesDynamicBodies","rawkinematiccharactercontroller_autostepEnabled","rawkinematiccharactercontroller_enableAutostep","rawkinematiccharactercontroller_disableAutostep","rawkinematiccharactercontroller_maxSlopeClimbAngle","rawkinematiccharactercontroller_setMaxSlopeClimbAngle","rawkinematiccharactercontroller_minSlopeSlideAngle","rawkinematiccharactercontroller_setMinSlopeSlideAngle","rawkinematiccharactercontroller_snapToGroundDistance","rawkinematiccharactercontroller_enableSnapToGround","rawkinematiccharactercontroller_disableSnapToGround","rawkinematiccharactercontroller_snapToGroundEnabled","rawkinematiccharactercontroller_computeColliderMovement","rawkinematiccharactercontroller_computedMovement","rawkinematiccharactercontroller_computedGrounded","rawkinematiccharactercontroller_numComputedCollisions","rawkinematiccharactercontroller_computedCollision","__wbg_rawcharactercollision_free","rawcharactercollision_new","rawcharactercollision_handle","rawcharactercollision_translationApplied","rawcharactercollision_translationRemaining","rawcharactercollision_toi","rawcharactercollision_worldWitness1","rawcharactercollision_worldWitness2","rawcharactercollision_worldNormal1","rawcharactercollision_worldNormal2","__wbg_rawccdsolver_free","rawccdsolver_new","rawimpulsejointset_jointType","rawimpulsejointset_jointBodyHandle1","rawimpulsejointset_jointBodyHandle2","rawimpulsejointset_jointFrameX1","rawimpulsejointset_jointFrameX2","rawimpulsejointset_jointAnchor1","rawimpulsejointset_jointAnchor2","rawimpulsejointset_jointSetAnchor1","rawimpulsejointset_jointSetAnchor2","rawimpulsejointset_jointContactsEnabled","rawimpulsejointset_jointSetContactsEnabled","rawimpulsejointset_jointLimitsEnabled","rawimpulsejointset_jointLimitsMin","rawimpulsejointset_jointLimitsMax","rawimpulsejointset_jointSetLimits","rawimpulsejointset_jointConfigureMotorModel","rawimpulsejointset_jointConfigureMotorVelocity","rawimpulsejointset_jointConfigureMotorPosition","rawimpulsejointset_jointConfigureMotor","__wbg_rawimpulsejointset_free","rawimpulsejointset_new","rawimpulsejointset_createJoint","rawimpulsejointset_remove","rawimpulsejointset_len","rawimpulsejointset_contains","rawimpulsejointset_forEachJointHandle","rawimpulsejointset_forEachJointAttachedToRigidBody","__wbg_rawintegrationparameters_free","rawintegrationparameters_new","rawintegrationparameters_dt","rawintegrationparameters_allowedLinearError","rawintegrationparameters_predictionDistance","rawintegrationparameters_maxVelocityIterations","rawintegrationparameters_maxVelocityFrictionIterations","rawintegrationparameters_maxStabilizationIterations","rawintegrationparameters_minIslandSize","rawintegrationparameters_maxCcdSubsteps","rawintegrationparameters_set_dt","rawintegrationparameters_set_erp","rawintegrationparameters_set_allowedLinearError","rawintegrationparameters_set_predictionDistance","rawintegrationparameters_set_maxVelocityIterations","rawintegrationparameters_set_maxVelocityFrictionIterations","rawintegrationparameters_set_maxStabilizationIterations","rawintegrationparameters_set_minIslandSize","rawintegrationparameters_set_maxCcdSubsteps","__wbg_rawislandmanager_free","rawislandmanager_new","rawislandmanager_forEachActiveRigidBodyHandle","__wbg_rawgenericjoint_free","rawgenericjoint_spherical","rawgenericjoint_prismatic","rawgenericjoint_fixed","rawgenericjoint_revolute","rawmultibodyjointset_jointType","rawmultibodyjointset_jointFrameX1","rawmultibodyjointset_jointFrameX2","rawmultibodyjointset_jointAnchor1","rawmultibodyjointset_jointAnchor2","rawmultibodyjointset_jointContactsEnabled","rawmultibodyjointset_jointSetContactsEnabled","rawmultibodyjointset_jointLimitsEnabled","rawmultibodyjointset_jointLimitsMin","rawmultibodyjointset_jointLimitsMax","__wbg_rawmultibodyjointset_free","rawmultibodyjointset_new","rawmultibodyjointset_createJoint","rawmultibodyjointset_remove","rawmultibodyjointset_contains","rawmultibodyjointset_forEachJointHandle","rawmultibodyjointset_forEachJointAttachedToRigidBody","rawrigidbodyset_rbTranslation","rawrigidbodyset_rbRotation","rawrigidbodyset_rbSleep","rawrigidbodyset_rbIsSleeping","rawrigidbodyset_rbIsMoving","rawrigidbodyset_rbNextTranslation","rawrigidbodyset_rbNextRotation","rawrigidbodyset_rbSetTranslation","rawrigidbodyset_rbSetRotation","rawrigidbodyset_rbSetLinvel","rawrigidbodyset_rbSetAngvel","rawrigidbodyset_rbSetNextKinematicTranslation","rawrigidbodyset_rbSetNextKinematicRotation","rawrigidbodyset_rbRecomputeMassPropertiesFromColliders","rawrigidbodyset_rbSetAdditionalMass","rawrigidbodyset_rbSetAdditionalMassProperties","rawrigidbodyset_rbLinvel","rawrigidbodyset_rbAngvel","rawrigidbodyset_rbLockTranslations","rawrigidbodyset_rbSetEnabledTranslations","rawrigidbodyset_rbLockRotations","rawrigidbodyset_rbSetEnabledRotations","rawrigidbodyset_rbDominanceGroup","rawrigidbodyset_rbSetDominanceGroup","rawrigidbodyset_rbEnableCcd","rawrigidbodyset_rbMass","rawrigidbodyset_rbInvMass","rawrigidbodyset_rbEffectiveInvMass","rawrigidbodyset_rbLocalCom","rawrigidbodyset_rbWorldCom","rawrigidbodyset_rbInvPrincipalInertiaSqrt","rawrigidbodyset_rbPrincipalInertiaLocalFrame","rawrigidbodyset_rbPrincipalInertia","rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt","rawrigidbodyset_rbEffectiveAngularInertia","rawrigidbodyset_rbWakeUp","rawrigidbodyset_rbIsCcdEnabled","rawrigidbodyset_rbNumColliders","rawrigidbodyset_rbCollider","rawrigidbodyset_rbBodyType","rawrigidbodyset_rbSetBodyType","rawrigidbodyset_rbIsFixed","rawrigidbodyset_rbIsKinematic","rawrigidbodyset_rbIsDynamic","rawrigidbodyset_rbLinearDamping","rawrigidbodyset_rbAngularDamping","rawrigidbodyset_rbSetLinearDamping","rawrigidbodyset_rbSetAngularDamping","rawrigidbodyset_rbSetEnabled","rawrigidbodyset_rbIsEnabled","rawrigidbodyset_rbGravityScale","rawrigidbodyset_rbSetGravityScale","rawrigidbodyset_rbResetForces","rawrigidbodyset_rbResetTorques","rawrigidbodyset_rbAddForce","rawrigidbodyset_rbApplyImpulse","rawrigidbodyset_rbAddTorque","rawrigidbodyset_rbApplyTorqueImpulse","rawrigidbodyset_rbAddForceAtPoint","rawrigidbodyset_rbApplyImpulseAtPoint","rawrigidbodyset_rbUserData","rawrigidbodyset_rbSetUserData","__wbg_rawrigidbodyset_free","rawrigidbodyset_new","rawrigidbodyset_createRigidBody","rawrigidbodyset_remove","rawrigidbodyset_len","rawrigidbodyset_contains","rawrigidbodyset_forEachRigidBodyHandle","rawrigidbodyset_propagateModifiedBodyPositionsToColliders","__wbg_rawbroadphase_free","rawbroadphase_new","rawcolliderset_coTranslation","rawcolliderset_coRotation","rawcolliderset_coSetTranslation","rawcolliderset_coSetTranslationWrtParent","rawcolliderset_coSetRotation","rawcolliderset_coSetRotationWrtParent","rawcolliderset_coIsSensor","rawcolliderset_coShapeType","rawcolliderset_coHalfspaceNormal","rawcolliderset_coHalfExtents","rawcolliderset_coSetHalfExtents","rawcolliderset_coRadius","rawcolliderset_coSetRadius","rawcolliderset_coHalfHeight","rawcolliderset_coSetHalfHeight","rawcolliderset_coRoundRadius","rawcolliderset_coSetRoundRadius","rawcolliderset_coVertices","rawcolliderset_coIndices","rawcolliderset_coHeightfieldHeights","rawcolliderset_coHeightfieldScale","rawcolliderset_coHeightfieldNRows","rawcolliderset_coHeightfieldNCols","rawcolliderset_coParent","rawcolliderset_coSetEnabled","rawcolliderset_coIsEnabled","rawcolliderset_coFriction","rawcolliderset_coRestitution","rawcolliderset_coDensity","rawcolliderset_coMass","rawcolliderset_coVolume","rawcolliderset_coCollisionGroups","rawcolliderset_coSolverGroups","rawcolliderset_coActiveHooks","rawcolliderset_coActiveCollisionTypes","rawcolliderset_coActiveEvents","rawcolliderset_coContactForceEventThreshold","rawcolliderset_coContainsPoint","rawcolliderset_coCastShape","rawcolliderset_coCastCollider","rawcolliderset_coIntersectsShape","rawcolliderset_coContactShape","rawcolliderset_coContactCollider","rawcolliderset_coProjectPoint","rawcolliderset_coIntersectsRay","rawcolliderset_coCastRay","rawcolliderset_coCastRayAndGetNormal","rawcolliderset_coSetSensor","rawcolliderset_coSetRestitution","rawcolliderset_coSetFriction","rawcolliderset_coFrictionCombineRule","rawcolliderset_coSetFrictionCombineRule","rawcolliderset_coRestitutionCombineRule","rawcolliderset_coSetRestitutionCombineRule","rawcolliderset_coSetCollisionGroups","rawcolliderset_coSetSolverGroups","rawcolliderset_coSetActiveHooks","rawcolliderset_coSetActiveEvents","rawcolliderset_coSetActiveCollisionTypes","rawcolliderset_coSetShape","rawcolliderset_coSetContactForceEventThreshold","rawcolliderset_coSetDensity","rawcolliderset_coSetMass","rawcolliderset_coSetMassProperties","__wbg_rawcolliderset_free","rawcolliderset_new","rawcolliderset_len","rawcolliderset_contains","rawcolliderset_createCollider","rawcolliderset_remove","rawcolliderset_forEachColliderHandle","__wbg_rawshapecontact_free","rawshapecontact_distance","__wbg_rawnarrowphase_free","rawnarrowphase_new","rawnarrowphase_contacts_with","rawnarrowphase_contact_pair","rawnarrowphase_intersections_with","rawnarrowphase_intersection_pair","__wbg_rawcontactmanifold_free","rawcontactpair_collider1","rawcontactpair_collider2","rawcontactpair_numContactManifolds","rawcontactpair_contactManifold","rawcontactmanifold_normal","rawcontactmanifold_local_n1","rawcontactmanifold_local_n2","rawcontactmanifold_subshape1","rawcontactmanifold_subshape2","rawcontactmanifold_num_contacts","rawcontactmanifold_contact_local_p1","rawcontactmanifold_contact_local_p2","rawcontactmanifold_contact_dist","rawcontactmanifold_contact_fid1","rawcontactmanifold_contact_fid2","rawcontactmanifold_contact_impulse","rawcontactmanifold_contact_tangent_impulse_x","rawcontactmanifold_contact_tangent_impulse_y","rawcontactmanifold_num_solver_contacts","rawcontactmanifold_solver_contact_point","rawcontactmanifold_solver_contact_dist","rawcontactmanifold_solver_contact_friction","rawcontactmanifold_solver_contact_restitution","rawcontactmanifold_solver_contact_tangent_velocity","__wbg_rawpointprojection_free","__wbg_rawpointcolliderprojection_free","rawpointcolliderprojection_colliderHandle","rawpointcolliderprojection_featureType","rawpointcolliderprojection_featureId","__wbg_rawrayintersection_free","rawrayintersection_featureType","rawrayintersection_featureId","rawraycolliderintersection_normal","rawraycolliderintersection_toi","rawraycolliderintersection_featureType","rawraycolliderintersection_featureId","__wbg_rawraycollidertoi_free","__wbg_rawshape_free","rawshape_cuboid","rawshape_roundCuboid","rawshape_ball","rawshape_halfspace","rawshape_capsule","rawshape_cylinder","rawshape_roundCylinder","rawshape_cone","rawshape_roundCone","rawshape_polyline","rawshape_trimesh","rawshape_heightfield","rawshape_segment","rawshape_triangle","rawshape_roundTriangle","rawshape_convexHull","rawshape_roundConvexHull","rawshape_convexMesh","rawshape_roundConvexMesh","rawshape_castShape","rawshape_intersectsShape","rawshape_contactShape","rawshape_containsPoint","rawshape_projectPoint","rawshape_intersectsRay","rawshape_castRay","rawshape_castRayAndGetNormal","__wbg_rawshapetoi_free","rawshapetoi_witness1","rawshapetoi_normal1","rawshapetoi_normal2","__wbg_rawshapecollidertoi_free","rawshapecollidertoi_witness2","rawshapecollidertoi_normal2","rawrotation_new","rawrotation_identity","rawrotation_y","rawrotation_w","rawvector_zero","rawvector_new","rawvector_set_y","rawvector_xyz","rawvector_yxz","rawvector_zxy","rawvector_xzy","rawvector_yzx","rawvector_zyx","rawsdpmatrix3_elements","__wbg_rawdebugrenderpipeline_free","rawdebugrenderpipeline_new","rawdebugrenderpipeline_vertices","rawdebugrenderpipeline_colors","rawdebugrenderpipeline_render","__wbg_raweventqueue_free","__wbg_rawcontactforceevent_free","rawcontactforceevent_collider2","rawcontactforceevent_total_force","rawcontactforceevent_total_force_magnitude","rawcontactforceevent_max_force_direction","rawcontactforceevent_max_force_magnitude","raweventqueue_new","raweventqueue_drainCollisionEvents","raweventqueue_drainContactForceEvents","raweventqueue_clear","__wbg_rawphysicspipeline_free","rawphysicspipeline_new","rawphysicspipeline_step","rawphysicspipeline_stepWithEvents","__wbg_rawquerypipeline_free","rawquerypipeline_new","rawquerypipeline_update","rawquerypipeline_castRay","rawquerypipeline_castRayAndGetNormal","rawquerypipeline_intersectionsWithRay","rawquerypipeline_intersectionWithShape","rawquerypipeline_projectPoint","rawquerypipeline_projectPointAndGetFeature","rawquerypipeline_intersectionsWithPoint","rawquerypipeline_castShape","rawquerypipeline_intersectionsWithShape","rawquerypipeline_collidersWithAabbIntersectingAabb","__wbg_rawdeserializedworld_free","rawdeserializedworld_takeGravity","rawdeserializedworld_takeIntegrationParameters","rawdeserializedworld_takeIslandManager","rawdeserializedworld_takeBroadPhase","rawdeserializedworld_takeNarrowPhase","rawdeserializedworld_takeBodies","rawdeserializedworld_takeColliders","rawdeserializedworld_takeImpulseJoints","rawdeserializedworld_takeMultibodyJoints","rawserializationpipeline_serializeAll","rawserializationpipeline_deserializeAll","__wbg_rawcontactpair_free","__wbg_rawraycolliderintersection_free","__wbg_rawrotation_free","__wbg_rawvector_free","__wbg_rawsdpmatrix3_free","rawserializationpipeline_new","__wbg_rawserializationpipeline_free","__wbindgen_add_to_stack_pointer","__wbindgen_free","__wbindgen_malloc","__wbindgen_exn_store","Vector3","VectorOps","raw","res","out","input","Quaternion","RotationOps","rot","SdpMatrix3","elements","SdpMatrix3Ops","sdpMatrix3","RigidBodyType","RigidBody","rawSet","colliderSet","enableX","enableY","enableZ","tra","vel","rawVel","type","angularInertiaLocalFrame","rawCom","rawPrincipalInertia","rawInertiaFrame","rawForce","rawImpulse","rawTorque","torqueImpulse","rawTorqueImpulse","rawPoint","RigidBodyDesc","translationsEnabledX","translationsEnabledY","translationsEnabledZ","rotationsEnabledX","rotationsEnabledY","rotationsEnabledZ","can","Coarena","elt","RigidBodySet","rb","desc","rawTra","rawRot","rawLv","rawAv","impulseJoints","multibodyJoints","IntegrationParameters","JointType","MotorModel","ImpulseJoint","bodySet","RevoluteImpulseJoint","PrismaticImpulseJoint","FixedImpulseJoint","SphericalImpulseJoint","UnitImpulseJoint","JointData","frame1","frame2","rawA1","rawA2","rawAx","rawFra1","rawFra2","ImpulseJointSet","joint","rawParams","MultibodyJoint","RevoluteMultibodyJoint","PrismaticMultibodyJoint","FixedMultibodyJoint","SphericalMultibodyJoint","UnitMultibodyJoint","MultibodyJointSet","CoefficientCombineRule","CCDSolver","IslandManager","BroadPhase","NarrowPhase","TempContactManifold","collider1","collider2","rawPair","flipped","ShapeContact","dist","point1","point2","normal1","normal2","FeatureType","PointProjection","isInside","PointColliderProjection","collider","featureType","featureId","Ray","origin","dir","RayIntersection","toi","RayColliderIntersection","RayColliderToi","ShapeTOI","witness1","witness2","ShapeColliderTOI","Shape","rawType","extents","vs","ShapeType","Ball","Cuboid","RoundCuboid","Capsule","Segment","Polyline","Triangle","RoundTriangle","HalfSpace","TriMesh","Heightfield","ConvexPolyhedron","RoundConvexPolyhedron","Cylinder","RoundCylinder","Cone","RoundCone","stopAtPenetration","rawPos1","rawRot1","rawVel1","rawPos2","rawRot2","rawVel2","rawShape1","rawShape2","rawPos","rawShape","ray","rawRayOrig","rawRayDir","n","a","b","ra","c","rc","rawScale","ActiveCollisionTypes","Collider","rawOrig","rawDir","rawCollider1Vel","rawShape2Pos","rawShape2Rot","rawShape2Vel","rawCollider2Vel","MassPropsMode","ColliderDesc","sensor","ColliderSet","parentHandle","PhysicsPipeline","ccdSolver","rawG","QueryFilterFlags","QueryPipeline","filterFlags","filterGroups","filterExcludeCollider","filterExcludeRigidBody","filterPredicate","rawCallback","rawInter","rawCenter","rawHalfExtents","SerializationPipeline","rawGra","World","DebugRenderBuffers","colors","DebugRenderPipeline","CharacterCollision","KinematicCharacterController","rawVect","desiredTranslation","rawTranslation","rawIntegrationParameters","rawIslands","rawBroadPhase","rawNarrowPhase","rawBodies","rawColliders","rawImpulseJoints","rawMultibodyJoints","rawCCDSolver","rawQueryPipeline","rawPhysicsPipeline","rawSerializationPipeline","rawDebugRenderPipeline","controller","niter","ActiveEvents","TempContactForceEvent","EventQueue","event","ActiveHooks","SolverFlags","vers"],"mappings":"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","x_google_ignoreList":[0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]}